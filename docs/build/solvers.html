<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · ModelVerification.jl</title><meta name="title" content="Solvers · ModelVerification.jl"/><meta property="og:title" content="Solvers · ModelVerification.jl"/><meta property="twitter:title" content="Solvers · ModelVerification.jl"/><meta name="description" content="Documentation for ModelVerification.jl."/><meta property="og:description" content="Documentation for ModelVerification.jl."/><meta property="twitter:description" content="Documentation for ModelVerification.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ModelVerification.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModelVerification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">ModelVerification.jl</a></li><li><span class="tocitem">Toolbox Outline</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Problem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="problem.html">Problem Outline</a></li><li><a class="tocitem" href="network.html">Network</a></li><li><a class="tocitem" href="safety_spec.html">Input-Output Specification</a></li></ul></li><li><a class="tocitem" href="branching.html">Branching</a></li><li><a class="tocitem" href="propagate.html">Propagation</a></li><li class="is-active"><a class="tocitem" href="solvers.html">Solvers</a><ul class="internal"><li><a class="tocitem" href="#Variations-of-propagation-methods"><span>Variations of propagation methods</span></a></li><li><a class="tocitem" href="#Bound-types"><span>Bound types</span></a></li><li><a class="tocitem" href="#Preprocessing-for-the-solver"><span>Preprocessing for the solver</span></a></li><li><a class="tocitem" href="#Checking-inclusion"><span>Checking inclusion</span></a></li><li><a class="tocitem" href="#ExactReach"><span>ExactReach</span></a></li><li><a class="tocitem" href="#Ai2"><span>Ai2</span></a></li><li><a class="tocitem" href="#ImageStar"><span>ImageStar</span></a></li><li><a class="tocitem" href="#ImageZono"><span>ImageZono</span></a></li><li><a class="tocitem" href="#Crown"><span>Crown</span></a></li><li><a class="tocitem" href="#\\alpha-Crown"><span><span>$\alpha$</span>-Crown</span></a></li><li><a class="tocitem" href="#\\beta-Crown"><span><span>$\beta$</span>-Crown</span></a></li></ul></li><li><a class="tocitem" href="attack.html">Attacks</a></li><li><a class="tocitem" href="utils.html">Helper Functions</a></li></ul></li><li><span class="tocitem">Python Interface</span><ul><li><a class="tocitem" href="nnet_converter.html">NNet Converter</a></li><li><a class="tocitem" href="python_interface.html">Python Interface</a></li></ul></li><li><a class="tocitem" href="existing_implementations.html">Existing Implementations</a></li><li><a class="tocitem" href="about.html">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Toolbox Outline</a></li><li class="is-active"><a href="solvers.html">Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="solvers.html">Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/intelligent-control-lab/ModelVerification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/master/docs/src/solvers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="solvers.html#Solvers">Solvers</a></li><li class="no-marker"><ul><li><a href="solvers.html#Variations-of-propagation-methods">Variations of propagation methods</a></li><li><a href="solvers.html#Bound-types">Bound types</a></li><li><a href="solvers.html#Preprocessing-for-the-solver">Preprocessing for the solver</a></li><li><a href="solvers.html#Checking-inclusion">Checking inclusion</a></li><li><a href="solvers.html#ExactReach">ExactReach</a></li><li><a href="solvers.html#Ai2">Ai2</a></li><li><a href="solvers.html#ImageStar">ImageStar</a></li><li><a href="solvers.html#ImageZono">ImageZono</a></li><li><a href="solvers.html#Crown">Crown</a></li><li><a href="solvers.html#\\alpha-Crown"><span>$\alpha$</span>-Crown</a></li><li><a href="solvers.html#\\beta-Crown"><span>$\beta$</span>-Crown</a></li></ul></li></ul><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>For most of the functions below, each solver has a unique dispatch defined.</p><h2 id="Variations-of-propagation-methods"><a class="docs-heading-anchor" href="#Variations-of-propagation-methods">Variations of propagation methods</a><a id="Variations-of-propagation-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Variations-of-propagation-methods" title="Permalink"></a></h2><p>All the solvers are based on one of the following propagation methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ForwardProp" href="#ModelVerification.ForwardProp"><code>ModelVerification.ForwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ForwardProp &lt;: PropMethod</code></pre><p>Abstract type representing solvers that use forward propagation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.BackwardProp" href="#ModelVerification.BackwardProp"><code>ModelVerification.BackwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BackwardProp &lt;: PropMethod</code></pre><p>Abstract type representing solvers that use backward propagation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.SequentialForwardProp" href="#ModelVerification.SequentialForwardProp"><code>ModelVerification.SequentialForwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialForwardProp &lt;: ForwardProp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L15-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.SequentialBackwardProp" href="#ModelVerification.SequentialBackwardProp"><code>ModelVerification.SequentialBackwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SequentialBackwardProp &lt;: ForwardProp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.BatchForwardProp" href="#ModelVerification.BatchForwardProp"><code>ModelVerification.BatchForwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchForwardProp &lt;: ForwardProp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.BatchBackwardProp" href="#ModelVerification.BatchBackwardProp"><code>ModelVerification.BatchBackwardProp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BatchBackwardProp &lt;: BackwardProp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L30-L32">source</a></section></article><h2 id="Bound-types"><a class="docs-heading-anchor" href="#Bound-types">Bound types</a><a id="Bound-types-1"></a><a class="docs-heading-anchor-permalink" href="#Bound-types" title="Permalink"></a></h2><p>The bounds are based on the following abstract type <code>Bound</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.Bound" href="#ModelVerification.Bound"><code>ModelVerification.Bound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bound</code></pre><p>Abstract type representing bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L35-L39">source</a></section></article><h2 id="Preprocessing-for-the-solver"><a class="docs-heading-anchor" href="#Preprocessing-for-the-solver">Preprocessing for the solver</a><a id="Preprocessing-for-the-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing-for-the-solver" title="Permalink"></a></h2><p><code>prepare_method</code> is the first step called in <a href="branching.html#ModelVerification.search_branches-Tuple{BFS, Vararg{Any, 4}}"><code>search_branches</code></a>. It initializes the bounds of the start node of the computational graph based on the given branch and the geometric representation used by the solver, which is specified with the <code>prop_method</code>. For each solver, there is a unique <code>prepare_method</code> defined. For more information, refer to the documentation for each solver.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_method-Tuple{PropMethod, AbstractVector, AbstractVector, Any}" href="#ModelVerification.prepare_method-Tuple{PropMethod, AbstractVector, AbstractVector, Any}"><code>ModelVerification.prepare_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_method(prop_method::PropMethod, batch_input::AbstractVector, batch_output::AbstractVector, model_info)</code></pre><p>Initialize the bound of the start node of the computational graph based on the  solver (<code>prop_method</code>).</p><p><strong>Agruments</strong></p><ul><li><code>prop_method</code> (<code>PropMethod</code>): Propagation method, i.e., the solver.</li><li><code>batch_input</code> (<code>AbstractVector</code>): Batch of inputs.</li><li><code>batch_output</code> (<code>AbstractVector</code>): Batch of outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to   be verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_output</code>: Batch of outputs.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L189-L205">source</a></section></article><p>The following functions are used to retrieve information regarding each node in the model.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_propagation-Tuple{ModelVerification.ForwardProp, Any, Any, Any}" href="#ModelVerification.init_propagation-Tuple{ModelVerification.ForwardProp, Any, Any, Any}"><code>ModelVerification.init_propagation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_propagation(prop_method::ForwardProp, batch_input, batch_output, model_info)</code></pre><p>Returns a dictionary containing the information of each node in the model. This  function is for <code>ForwardProp</code> solvers, and is mainly concerned with initializing  the dictionary, <code>batch_info</code>, and populating it with the initial bounds for the  starting node. For the starting node of the model, the <code>:bound</code> key is mapped  to the list of input specifications.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver that uses forward propagation.</li><li><code>batch_input</code>: List of inputs.</li><li><code>batch_output</code>: List of outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to    be verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L137-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_propagation-Tuple{ModelVerification.BackwardProp, Any, Any, Any}" href="#ModelVerification.init_propagation-Tuple{ModelVerification.BackwardProp, Any, Any, Any}"><code>ModelVerification.init_propagation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_propagation(prop_method::BackwardProp, batch_input, batch_output, model_info)</code></pre><p>Returns a dictionary containing the information of each node in the model. This  function is for <code>BackwardProp</code> solvers, and is mainly concerned with  initializing the dictionary, <code>batch_info</code>, and populating it with the initial  bounds for the starting node. For the starting node of the model, the <code>:bound</code>  key is mapped to the list of input specifications.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BackwardProp</code>): Solver that uses backward propagation.</li><li><code>batch_input</code>: List of inputs.</li><li><code>batch_output</code>: List of outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to    be verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L163-L181">source</a></section></article><p>The following functions are used to either retrieve or process the safety specification.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_batch_bound-Tuple{ModelVerification.ForwardProp, Any, Any}" href="#ModelVerification.init_batch_bound-Tuple{ModelVerification.ForwardProp, Any, Any}"><code>ModelVerification.init_batch_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_batch_bound(prop_method::ForwardProp, batch_input, batch_output)</code></pre><p>Returns a list of the input specifications (geometries) for the given batch of  inputs. This is for <code>ForwardProp</code> solvers. Each input specification is  processed to fit the geometric representation used by the solver.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver that uses forward propagation method.</li><li><code>batch_input</code>: Array of inputs.</li><li><code>batch_output</code>: Array of outputs.</li></ul><p><strong>Returns</strong></p><ul><li>List of the input specifications for the given batch of inputs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L42-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_batch_bound-Tuple{ModelVerification.BackwardProp, Any, Any}" href="#ModelVerification.init_batch_bound-Tuple{ModelVerification.BackwardProp, Any, Any}"><code>ModelVerification.init_batch_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_batch_bound(prop_method::BackwardProp, batch_input, batch_output)</code></pre><p>Returns a list of the output specifications (geometries) for the given batch of  outputs. This is for <code>BackwardProp</code> solvers. Each input specification is  processed to fit the geometric representation used by the solver.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BackwardProp</code>): Solver that uses backward propagation method.</li><li><code>batch_input</code>: Array of inputs.</li><li><code>batch_output</code>: Array of outputs.</li></ul><p><strong>Returns</strong></p><ul><li>List of the output specifications for the given batch of outputs.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L61-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ModelVerification.ForwardProp, Any}" href="#ModelVerification.init_bound-Tuple{ModelVerification.ForwardProp, Any}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::ForwardProp, input)</code></pre><p>Returns the geometry representation used to encode the input specification. This is for <code>ForwardProp</code> solvers. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver that uses forward propagation method. </li><li><code>input</code>: Geometry representation used to encode the input specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>input</code>: Geometry representation used to encode the input specification.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L80-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ModelVerification.BackwardProp, Any}" href="#ModelVerification.init_bound-Tuple{ModelVerification.BackwardProp, Any}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::BackwardProp, output)</code></pre><p>Returns the geometry representation used to encode the output specification.  This is for <code>BackwardProp</code> solvers.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BackwardProp</code>): Solver that uses backward propagation method. </li><li><code>output</code>: Geometry representation used to encode the output specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>output</code>: Geometry representation used to encode the output specification.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.process_bound" href="#ModelVerification.process_bound"><code>ModelVerification.process_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_bound(prop_method::PropMethod, batch_bound, batch_out_spec, model_info, batch_info)</code></pre><p>Returns the list of bounds resulting from the propagation and the information of the batch.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>PropMethod</code>): Solver.</li><li><code>batch_bound</code>: List of the bounds for the given batch.</li><li><code>batch_out_spec</code>: List of the output specifications for the given batch of    outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: List of the bounds for the given batch.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L114-L132">source</a></section><section><div><pre><code class="language-julia hljs">process_bound(prop_method::BetaCrown, batch_bound::BetaCrownBound, batch_out_spec, model_info, batch_info)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/beta-crown.jl#L346-L348">source</a></section></article><h2 id="Checking-inclusion"><a class="docs-heading-anchor" href="#Checking-inclusion">Checking inclusion</a><a id="Checking-inclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Checking-inclusion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, AbstractArray, AbstractArray, AbstractArray}" href="#ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, AbstractArray, AbstractArray, AbstractArray}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ForwardProp, model, batch_input::AbstractArray, batch_reach::AbstractArray, batch_output::AbstractArray)</code></pre><p>Determines whether the reachable sets, <code>batch_reach</code>, are within the respective  valid output sets, <code>batch_output</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>AbstractArray</code>): List of input specifications.</li><li><code>reach</code> (<code>AbstractArray</code>): List of reachable sets.</li><li><code>output</code> (<code>AbstractArray</code>) : List of sets of valid outputs.</li></ul><p><strong>Returns</strong></p><p>List of a combination of the following components:</p><ul><li><code>ReachabilityResult(:holds, [reach])</code> if <code>reach</code> is a subset of <code>output</code>.</li><li><code>CounterExampleResult(:unknown)</code> if <code>reach</code> is not a subset of <code>output</code>, but    cannot find a counterexample.</li><li><code>CounterExampleResult(:violated, x)</code> if <code>reach</code> is not a subset of <code>output</code>,    and there is a counterexample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/solver.jl#L211-L232">source</a></section></article><h2 id="ExactReach"><a class="docs-heading-anchor" href="#ExactReach">ExactReach</a><a id="ExactReach-1"></a><a class="docs-heading-anchor-permalink" href="#ExactReach" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ExactReach" href="#ModelVerification.ExactReach"><code>ModelVerification.ExactReach</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactReach &lt;: SequentialForwardProp</code></pre><p><code>ExactReach</code> performs exact reachability analysis to compute the exact reachable  set for a network. It works for piecewise linear networks with either linear or  ReLU activations. It computes the reachable set for every linear segment of the  network and keeps track of all sets. The final reachable set is the union of all  sets. Since the number of linear segments is exponential in the number of nodes  in one layer, this method is not scalable.</p><p><strong>Problem Requirement</strong></p><ol><li>Network: any depth, ReLU activation (more activations to be supported in the future)</li><li>Input: Array of AbstractPolytope, i.e., union of polytopes.</li><li>Output: Array of AbstractPolytope, i.e., union of polytopes.</li></ol><p><strong>Returns</strong></p><p><code>BasicResult(:holds)</code>, <code>BasicResult(:violated)</code></p><p><strong>Method</strong></p><p>Reachability analysis using split and join.</p><p><strong>Property</strong></p><p>Sound and complete.</p><p><strong>Reference</strong></p><p>[1] C. Liu, T. Arnon, C. Lazarus, C. Strong, C. Barret, and M. J. Kochenderfer,  &quot;Algorithms for Verifying Deep Neural Networks,&quot; in <em>Foundations and Trends in  Optimization</em>, 2021.</p><p>[2] W. Xiang, H.-D. Tran, and T. T. Johnson, &quot;Reachable Set Computation and  Safety Verification for Neural Networks with ReLU Activations,&quot; ArXiv Preprint  <em>ArXiv:1712.08163</em>, 2017.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ExactReachBound" href="#ModelVerification.ExactReachBound"><code>ModelVerification.ExactReachBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactReachBound &lt;: Bound</code></pre><p>Bound for <code>ExactReach</code> solver. It is a union of polytopes, represented with an  array of <code>LazySet</code>.</p><p><strong>Fields</strong></p><ul><li><code>polys</code> (<code>AbstractArray{LazySet}</code>): Array of polytopes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.center-Tuple{ModelVerification.ExactReachBound}" href="#ModelVerification.center-Tuple{ModelVerification.ExactReachBound}"><code>ModelVerification.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(bound::ExactReachBound)</code></pre><p>Returns a randomly sampled point from the first polytope in the array of  polytopes, <code>bound.polys</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ExactReachBound</code>): The <code>ExactReachBound</code> to sample from.</li></ul><p><strong>Returns</strong></p><ul><li>A randomly sampled point from the first polytope in the array of polytopes.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L49-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ExactReach, Problem}" href="#ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ExactReach, Problem}"><code>ModelVerification.prepare_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_problem(search_method::SearchMethod, split_method::SplitMethod, 
                prop_method::ExactReach, problem::Problem)</code></pre><p>Preprocessing of the <code>Problem</code> to be solved. This method converts the model to a  bounded computational graph, makes the input specification compatible with the  solver, and returns the model information and preprocessed <code>Problem</code>. This in  turn also initializes the branch bank.</p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>SearchMethod</code>): Method to search the branches.</li><li><code>split_method</code> (<code>SplitMethod</code>): Method to split the branches.</li><li><code>prop_method</code> (<code>ExactReach</code>): Solver to be used, specifically the    <code>ExactReach</code>.</li><li><code>problem</code> (<code>Problem</code>): Problem to be preprocessed to better fit the solver.</li></ul><p><strong>Returns</strong></p><ul><li><code>model_info</code>, a structure containing the information of the neural network to    be verified.</li><li><code>Problem</code> after processing the initial input specification and model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ExactReach, LazySets.LazySet}" href="#ModelVerification.init_bound-Tuple{ExactReach, LazySets.LazySet}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::ExactReach, bound::LazySet)</code></pre><p>For the <code>ExactReach</code> solver, this function converts the input set, represented  with a <code>LazySet</code>, to an <code>ExactReachBound</code> representation. This serves as a  preprocessing step for the <code>ExactReach</code> solver.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ExactReach</code>): <code>ExactReach</code> solver.</li><li><code>bound</code> (<code>LazySet</code>): Input set, represented with a <code>LazySet</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ExactReachBound</code> representation of the input set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ExactReach, Any, ModelVerification.ExactReachBound, ModelVerification.ExactReachBound, LazySets.LazySet}" href="#ModelVerification.check_inclusion-Tuple{ExactReach, Any, ModelVerification.ExactReachBound, ModelVerification.ExactReachBound, LazySets.LazySet}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ExactReach, model, input::ExactReachBound, 
                reach::ExactReachBound, output::LazySet)</code></pre><p>Determines whether the reachable set, <code>reach</code>, is within the valid output  specified by a <code>LazySet</code>. This function achieves this by directly checking if  all the reachable sets in <code>reach</code> are subsets of the set of valid outputs  <code>output</code>. If not, it returns <code>BasicResult(:violated)</code>. Otherwise, it returns  <code>BasicResult(:holds)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ExactReach</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>ExactReachBound</code>): Input specification represented with an    <code>ExactReachBound</code>.</li><li><code>reach</code> (<code>ExactReachBound</code>): Reachable set resulting from the propagation of   <code>input</code> through the <code>model</code>, represented with an <code>ExactReachBound</code>.</li><li><code>output</code> (<code>LazySet</code>): Set of valid outputs represented with a <code>LazySet</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicResult(:holds)</code> if all reachable sets in <code>reach</code> are subsets of    <code>output</code>.</li><li><code>BasicResult(:violated)</code> if any reachable set in <code>reach</code> is not a subset of    <code>output</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/exact-reach.jl#L109-L133">source</a></section></article><h2 id="Ai2"><a class="docs-heading-anchor" href="#Ai2">Ai2</a><a id="Ai2-1"></a><a class="docs-heading-anchor-permalink" href="#Ai2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.Ai2" href="#ModelVerification.Ai2"><code>ModelVerification.Ai2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ai2{T&lt;:Union{Hyperrectangle, Zonotope, HPolytope, Star}} 
                                &lt;: SequentialForwardProp</code></pre><p><code>Ai2</code> performs over-approximated reachability analysis to compute the over- approximated output reachable set for a network. <code>T</code> can be <code>Hyperrectangle</code>,  <code>Zonotope</code>, <code>Star</code>, or <code>HPolytope</code>. Different geometric representations impact the verification performance due to different over-approximation sizes.  We use <code>Zonotope</code> as &quot;benchmark&quot; geometry, as in the original implementation[1],  due to improved scalability and precision (similar results can be achieved using  <code>Star</code>). On the other hand, using a <code>HPolytope</code> representation potentially  leads to a more precise but less scalable result, and the opposite holds for  <code>Hyperrectangle</code>.</p><p>Note that initializing <code>Ai2()</code> defaults to <code>Ai2{Zonotope}</code>. The following aliases also exist for convenience:</p><p><strong>Problem Requirement</strong></p><ol><li>Network: any depth, ReLU activation (more activations to be supported in the   future)</li><li>Input: AbstractPolytope</li></ol><pre><code class="language-Julia hljs">const Ai2h = Ai2{HPolytope}
const Ai2z = Ai2{Zonotope}
const Ai2s = Ai2{Star}
const Box = Ai2{Hyperrectangle}</code></pre><ol><li>Output:  AbstractPolytope</li></ol><p><strong>Returns</strong></p><p><code>ReachabilityResult</code>, <code>CounterExampleResult</code></p><p><strong>Method</strong></p><p>Reachability analysis using split and join.</p><p><strong>Property</strong></p><p>Sound but not complete.</p><p><strong>Reference</strong></p><p>[1] T. Gehr, M. Mirman, D. Drashsler-Cohen, P. Tsankov, S. Chaudhuri, and  M. Vechev, &quot;Ai2: Safety and Robustness Certification of Neural Networks with  Abstract Interpretation,&quot; in <em>2018 IEEE Symposium on Security and Privacy (SP)</em>, </p><ol><li></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.StarSet" href="#ModelVerification.StarSet"><code>ModelVerification.StarSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StarSet</code></pre><p>Covers supported Ai2 variations: Ai2h, Ai2z, Ai2s, Box.</p><p><strong>Fields</strong></p><ul><li><code>pre_bound_method</code> (<code>Union{SequentialForwardProp, Nothing}</code>): The geometric    representation used to compute the over-approximation of the input bounds.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L54-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_method-Tuple{StarSet, AbstractVector, AbstractVector, Any}" href="#ModelVerification.prepare_method-Tuple{StarSet, AbstractVector, AbstractVector, Any}"><code>ModelVerification.prepare_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_method(prop_method::StarSet, batch_input::AbstractVector, 
batch_output::AbstractVector, model_info)</code></pre><p>Initialize the bound of the start node of the computational graph for the  <code>StarSet</code> solvers.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>StarSet</code>) : Propagation method of type <code>StarSet</code>.</li><li><code>batch_input</code> (<code>AbstractVector</code>) : Batch of inputs.</li><li><code>batch_output</code> (<code>AbstractVector</code>) : Batch of outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to   be verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_output</code>: batch of outputs.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L68-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.compute_bound-Tuple{LazySets.Zonotope}" href="#ModelVerification.compute_bound-Tuple{LazySets.Zonotope}"><code>ModelVerification.compute_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bound(bound::Zonotope)</code></pre><p>Computes the lower- and upper-bounds of a zonotope.  This function is used when propagating through the layers of the model. Radius is the sum of the absolute value of the generators of the given zonotope.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>Zonotope</code>) : zonotope of which the bounds need to be computed</li></ul><p><strong>Returns</strong></p><ul><li>Lower- and upper-bounds of the Zonotope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L110-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.compute_bound-Tuple{LazySets.Star}" href="#ModelVerification.compute_bound-Tuple{LazySets.Star}"><code>ModelVerification.compute_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bound(bound::Star)</code></pre><p>Computes the lower- and upper-bounds of a star set.  This function is used when propagating through the layers of the model. It overapproximates the given star set with a hyperrectangle.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>Star</code>): Star set of which the bounds need to be computed.</li></ul><p><strong>Returns</strong></p><ul><li>Lower- and upper-bounds of the overapproximated hyperrectangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L128-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{StarSet, LazySets.Hyperrectangle}" href="#ModelVerification.init_bound-Tuple{StarSet, LazySets.Hyperrectangle}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::StarSet, input::Hyperrectangle)</code></pre><p>Given a hyperrectangle as <code>input</code>, this function returns a star set that  encompasses the hyperrectangle. This helps a more precise computation of bounds.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>StarSet</code>): <code>StarSet</code>-type solver; includes <code>Ai2h</code>, <code>Ai2z</code>,    <code>Ai2s</code>, <code>Box</code>.</li><li><code>input</code> (<code>Hyperrectangle</code>): Hyperrectangle to be converted into a star set</li></ul><p><strong>Returns</strong></p><ul><li><code>Star</code> set that encompasses the given hyperrectangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L146-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, LazySets.LazySet, LazySets.LazySet, LazySets.LazySet}" href="#ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, LazySets.LazySet, LazySets.LazySet, LazySets.LazySet}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ForwardProp, model, input::LazySet, 
reach::LazySet, output::LazySet)</code></pre><p>Determines whether the reachable set, <code>reach</code>, is within the valid  output specified by a <code>LazySet</code>. This function achieves this by directly  checking if the reachable set <code>reach</code> is a subset of the set of valid outputs  <code>output</code>. If not, it attempts to find a counterexample and returns the  appropriate <code>Result</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>LazySet</code>): Input specification supported by <code>LazySet</code>.</li><li><code>reach</code> (<code>LazySet</code>): Reachable set resulting from the propagation of <code>input</code>    through the <code>model</code>.</li><li><code>output</code> (<code>LazySet</code>) : Set of valid outputs represented with a <code>LazySet</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ReachabilityResult(:holds, [reach])</code> if <code>reach</code> is a subset of <code>output</code>.</li><li><code>CounterExampleResult(:unknown)</code> if <code>reach</code> is not a subset of <code>output</code>, but    cannot find a counterexample.</li><li><code>CounterExampleResult(:violated, x)</code> if <code>reach</code> is not a subset of <code>output</code>,    and there is a counterexample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L174-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, LazySets.LazySet, LazySets.LazySet, LazySets.Complement}" href="#ModelVerification.check_inclusion-Tuple{ModelVerification.ForwardProp, Any, LazySets.LazySet, LazySets.LazySet, LazySets.Complement}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ForwardProp, model, input::LazySet, 
reach::LazySet, output::Complement)</code></pre><p>Determines whether the reachable set, R(input, model), is within the valid  output specified by a <code>LazySet</code>. This function achieves this by checking if the box approximation (overapproximation with hyperrectangle) of the <code>reach</code> set is disjoint with the <code>unsafe_output</code>. If the box approximation is a subset of the  <code>unsafe_output</code>, then the safety property is violated. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>LazySet</code>): Input specification supported by <code>Lazyset</code>.</li><li><code>reach</code> (<code>LazySet</code>): Reachable set resulting from the propagation of <code>input</code>    through the <code>model</code>.</li><li><code>output</code> (<code>Complement</code>): Set of valid outputs represented with a complement    set. For problems using this <code>check_inclusion</code> method, the unsafe region is    specified. Then, the complement of the unsafe region is given as the desired    output specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>ReachabilityResult(:holds, [reach])</code> if <code>box_reach</code> is disjoint with the   complement of the <code>output</code>.</li><li><code>CounterExampleResult(:violated, x)</code> if the center of the <code>input</code> set results    in a state that belongs to the <code>unsafe_output</code>.</li><li><code>CounterExampleResult(:unknown)</code> if either the two cases above are true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/polytope.jl#L211-L238">source</a></section></article><h2 id="ImageStar"><a class="docs-heading-anchor" href="#ImageStar">ImageStar</a><a id="ImageStar-1"></a><a class="docs-heading-anchor-permalink" href="#ImageStar" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ImageStar" href="#ModelVerification.ImageStar"><code>ModelVerification.ImageStar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageStar &lt;: SequentialForwardProp</code></pre><p>ImageStar is a verification approach that can verify the robustness of  Convolutional Neural Network (CNN). This toolbox uses the term, <code>ImageStar</code>, as  the verification method itself that uses the ImageStar set. In terms of  geometric representation, an ImageStar is an extension of the generalized star set such that the center and generators are images with multiple channels.</p><p><span>$Θ = \{ x : x = c + ∑_{i=1}^{m} (α_i v_i), \; Cα ≤ d \}$</span></p><p>where <span>$c$</span> is the center image, <span>$V = \{ v_1, …, v_m \}$</span> is the set of generator images, and <span>$Cα ≤ d$</span> represent the predicate with α&#39;s as the free  parameters. This set representation enables efficient over-approximative  analysis of CNNs. ImageStar is less conservative and faster than ImageZono [1].</p><p>Note that initializing <code>ImageStar()</code> defaults to <code>ImageStar(nothing)</code>.</p><p><strong>Fields</strong></p><ul><li><code>pre_bound_method</code> (<code>Union{SequentialForwardProp, Nothing}</code>): The geometric    representation used to compute the over-approximation of the input bounds.</li></ul><p><strong>Reference</strong></p><p>[1] HD. Tran, S. Bak, W. Xiang, and T.T. Johnson, &quot;Verification of Deep Convolutional  Neural Networks Using ImageStars,&quot; in <em>Computer Aided Verification (CAV)</em>, 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ImageStarBound" href="#ModelVerification.ImageStarBound"><code>ModelVerification.ImageStarBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageStarBound{T&lt;:Real} &lt;: Bound</code></pre><p><code>ImageStarBound</code> is used to represent the bounded set for <code>ImageStar</code>.  It is an extension of the geometric representation, <code>StarSet</code>.</p><p><strong>Fields</strong></p><ul><li><code>center</code> (<code>AbstractArray{T, 4}</code>): center image (&quot;anchor&quot; image in literature),    of size <code>heigth x width x number of channels x 1</code>.</li><li><code>generators</code> (<code>AbstractArray{T, 4}</code>): matrix of generator images, of size   <code>height x width x number of channels x number of generators</code>.</li><li><code>A</code> (<code>AbstractArray{T, 2}</code>): normal direction of the predicate, of size    <code>number of constraints x number of generators</code>.</li><li><code>b</code> (<code>AbstractArray{T, 1}</code>): constraints of the predicate, of size    <code>number of constraints x number of generators</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L32-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ImageStar, Problem}" href="#ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ImageStar, Problem}"><code>ModelVerification.prepare_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_problem(search_method::SearchMethod, split_method::SplitMethod, 
                prop_method::ImageStar, problem::Problem)</code></pre><p>Preprocessing of the <code>Problem</code> to be solved. This method converts the model to a  bounded computational graph, makes the input specification compatible with the  solver, and returns the model information and preprocessed <code>Problem</code>. This in  turn also initializes the branch bank.</p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>SearchMethod</code>): Method to search the branches.</li><li><code>split_method</code> (<code>SplitMethod</code>): Method to split the branches.</li><li><code>prop_method</code> (<code>ImageStar</code>): Solver to be used, specifically the <code>ImageStar</code>.</li><li><code>problem</code> (<code>Problem</code>): Problem to be preprocessed to better fit the solver.</li></ul><p><strong>Returns</strong></p><ul><li><code>model_info</code>, a structure containing the information of the neural network to    be verified.</li><li><code>Problem</code> after processing the initial input specification and model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L55-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_method-Tuple{ImageStar, AbstractVector, AbstractVector, Any}" href="#ModelVerification.prepare_method-Tuple{ImageStar, AbstractVector, AbstractVector, Any}"><code>ModelVerification.prepare_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_method(prop_method::ImageStar, batch_input::AbstractVector,
               batch_output::AbstractVector, model_info)</code></pre><p>Initialize the bound of the start node of the computational graph based on the  <code>pre_bound_method</code> specified in the given ImageStar solver.</p><p><strong>Agruments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): ImageStar solver.</li><li><code>batch_input</code> (<code>AbstractVector</code>): Batch of inputs.</li><li><code>batch_output</code> (<code>AbstractVector</code>): Batch of outputs.</li><li><code>model_info</code>: Structure containing the information of the neural network to   be verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_output</code>: Batch of outputs.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L80-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ImageStar, ImageConvexHull}" href="#ModelVerification.init_bound-Tuple{ImageStar, ImageConvexHull}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::ImageStar, ch::ImageConvexHull)</code></pre><p>For the <code>ImageStar</code> solver, this function converts the input set, represented  with an <code>ImageConvexHull</code>, to an <code>ImageStarBound</code> representation. This serves as  a preprocessing step for the <code>ImageStar</code> solver. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): <code>ImageStar</code> solver.</li><li><code>ch</code> (<code>ImageConvexHull</code>): Convex hull, type <code>ImageConvexHull</code>, is used for the    input specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>ImageStarBound</code> set that encompasses the given <code>ImageConvexHull</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L100-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.assert_zono_star-Tuple{ModelVerification.ImageStarBound}" href="#ModelVerification.assert_zono_star-Tuple{ModelVerification.ImageStarBound}"><code>ModelVerification.assert_zono_star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assert_zono_star(bound::ImageStarBound)</code></pre><p>Asserts whether the given <code>ImageStarBound</code> set is a Zonotope. This is done by checking whether the free parameter belongs to a unit hypercube.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.compute_bound-Tuple{ModelVerification.ImageStarBound}" href="#ModelVerification.compute_bound-Tuple{ModelVerification.ImageStarBound}"><code>ModelVerification.compute_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bound(bound::ImageStarBound)</code></pre><p>Computes the lower- and upper-bounds of an image star set. This function is used when propagating through the layers of the model. It converts the image star set to a star set. Then, it overapproximates this  star set with a hyperrectangle.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ImageStarBound</code>): Image star set of which the bounds need to be    computed.</li></ul><p><strong>Returns</strong></p><ul><li>Lower- and upper-bounds of the overapproximated hyperrectangle.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L143-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.center-Tuple{ModelVerification.ImageStarBound}" href="#ModelVerification.center-Tuple{ModelVerification.ImageStarBound}"><code>ModelVerification.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(bound::ImageStarBound)</code></pre><p>Returns the center image of the <code>ImageStarBound</code> bound.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ImageStarBound</code>): Geometric representation of the specification    using <code>ImageStarBound</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ImageStarBound.center</code> image of type <code>AbstractArray{T, 4}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L168-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ImageStar, Any, ModelVerification.ImageStarBound, LazySets.LazySet, LazySets.LazySet}" href="#ModelVerification.check_inclusion-Tuple{ImageStar, Any, ModelVerification.ImageStarBound, LazySets.LazySet, LazySets.LazySet}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ImageStar, model, input::ImageStarBound, 
                reach::LazySet, output::LazySet)</code></pre><p>Determines whether the reachable set, <code>reach</code>, is within the valid output  specified by a <code>LazySet</code>. </p><p><strong>Agruments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>ImageStarBound</code>): Input specification supported by <code>ImageStarBound</code>.</li><li><code>reach</code> (<code>LazySet</code>): Reachable set resulting from the propagation of <code>input</code>    through the <code>model</code>.</li><li><code>output</code> (<code>LazySet</code>): Set of valid outputs represented with a <code>LazySet</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ReachabilityResult(:holds, box_reach)</code> if <code>reach</code> is a subset of <code>output</code>,    the function returns <code>:holds</code> with the box approximation (overapproximation    with hyperrectangle) of the <code>reach</code> set.</li><li><code>CounterExampleResult(:unknown)</code> if <code>reach</code> is not a subset of <code>output</code>, but    cannot find a counterexample.</li><li><code>CounterExampleResult(:violated, x)</code> if <code>reach</code> is not a subset of <code>output</code>,    and there is a counterexample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-star.jl#L182-L205">source</a></section></article><h2 id="ImageZono"><a class="docs-heading-anchor" href="#ImageZono">ImageZono</a><a id="ImageZono-1"></a><a class="docs-heading-anchor-permalink" href="#ImageZono" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ImageZono" href="#ModelVerification.ImageZono"><code>ModelVerification.ImageZono</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageZono &lt;: SequentialForwardProp</code></pre><p>ImageZono is a verification approach that uses Image Zonotope as the geometric  representation. It is an extension of <code>ImageStar</code> where there is no linear  constraints on the free parameters, α:</p><p><span>$Θ = \{ x : x = c + ∑_{i=1}^{m} (α_i v_i) \}$</span></p><p>where <span>$c$</span> is the center image, <span>$V = \{ v_1, …, v_m \}$</span> is the set of generator images, and α&#39;s are the free parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.ImageZonoBound" href="#ModelVerification.ImageZonoBound"><code>ModelVerification.ImageZonoBound</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ImageZonoBound{T&lt;:Real} &lt;: Bound</code></pre><p><code>ImageZonoBound</code> is used to represent the bounded set for <code>ImageZono</code>.</p><p><strong>Fields</strong></p><ul><li><code>center</code> (<code>AbstractArray{T, 4}</code>): center image (&quot;anchor&quot; image in literature),    of size <code>heigth x width x number of channels x 1</code>.</li><li><code>generators</code> (<code>AbstractArray{T, 4}</code>): matrix of generator images, of size   <code>height x width x number of channels x number of generators</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L15-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ImageZono, Problem}" href="#ModelVerification.prepare_problem-Tuple{SearchMethod, SplitMethod, ImageZono, Problem}"><code>ModelVerification.prepare_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepare_problem(search_method::SearchMethod, split_method::SplitMethod, 
                prop_method::ImageZono, problem::Problem)</code></pre><p>Converts the model to a bounded computational graph and makes input  specification compatible with the solver, <code>prop_method</code>. This in turn also  initializes the branch bank.</p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>SearchMethod</code>): Method to search the branches.</li><li><code>split_method</code> (<code>SplitMethod</code>): Method to split the branches.</li><li><code>prop_method</code> (<code>ImageZono</code>): Solver to be used, specifically the <code>ImageZono</code>.</li><li><code>problem</code> (<code>Problem</code>): Problem to be preprocessed to better fit the solver.</li></ul><p><strong>Returns</strong></p><ul><li><code>model_info</code>, a structure containing the information of the neural network to    be verified.</li><li><code>Problem</code> after processing the initial input specification and model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L31-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ImageZono, ImageConvexHull}" href="#ModelVerification.init_bound-Tuple{ImageZono, ImageConvexHull}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::ImageZono, ch::ImageConvexHull)</code></pre><p>For the <code>ImageZono</code> solver, this function converts the input set, represented  with an <code>ImageConvexHull</code>, to an <code>ImageZonoBound</code> representation. This serves as  a preprocessing step for the <code>ImageZono</code> solver. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageZono</code>): <code>ImageZono</code> solver.</li><li><code>ch</code> (<code>ImageConvexHull</code>): Convex hull, type <code>ImageConvexHull</code>, is used as the    input specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>ImageZonoBound</code> set that encompasses the given <code>ImageConvexHull</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.init_bound-Tuple{ImageZono, ModelVerification.ImageStarBound}" href="#ModelVerification.init_bound-Tuple{ImageZono, ModelVerification.ImageStarBound}"><code>ModelVerification.init_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_bound(prop_method::ImageZono, bound::ImageStarBound)</code></pre><p>For the <code>ImageZono</code> solver, if the input set, represented with an  <code>ImageStarBound</code>, is a zonotope, this function converts it to an  <code>ImageZonoBound</code> representation.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageZono</code>): <code>ImageZono</code> solver.</li><li><code>ch</code> (<code>ImageStarBound</code>): <code>ImageStarBound</code> is used for the input specification.</li></ul><p><strong>Returns</strong></p><ul><li><code>ImageZonoBound</code> representation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L77-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.compute_bound-Tuple{ModelVerification.ImageZonoBound}" href="#ModelVerification.compute_bound-Tuple{ModelVerification.ImageZonoBound}"><code>ModelVerification.compute_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_bound(bound::ImageZonoBound)</code></pre><p>Computes the lower- and upper-bounds of an image zono set. This function is used when propagating through the layers of the model. It converts the image zono set to a zonotope. Then, it computes the bounds using  <code>compute_bound(bound::Zonotope)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ImageZonoBound</code>): Image zono set of which the bounds need to be    computed.</li></ul><p><strong>Returns</strong></p><ul><li>Lower- and upper-bounds of the flattened zonotope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L96-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.center-Tuple{ModelVerification.ImageZonoBound}" href="#ModelVerification.center-Tuple{ModelVerification.ImageZonoBound}"><code>ModelVerification.center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">center(bound::ImageZonoBound)</code></pre><p>Returns the center image of the <code>ImageZonoBound</code> bound.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ImageZonoBound</code>): Geometric representation of the specification    using <code>ImageZonoBound</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ImageZonoBound.center</code> image of type <code>AbstractArray{T, 4}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L121-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.check_inclusion-Tuple{ImageZono, Any, ModelVerification.ImageZonoBound, LazySets.LazySet, LazySets.LazySet}" href="#ModelVerification.check_inclusion-Tuple{ImageZono, Any, ModelVerification.ImageZonoBound, LazySets.LazySet, LazySets.LazySet}"><code>ModelVerification.check_inclusion</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inclusion(prop_method::ImageZono, model, input::ImageZonoBound, 
                reach::LazySet, output::LazySet)</code></pre><p>Determines whether the reachable set, <code>reach</code>, is within the valid output  specified by a <code>LazySet</code>.</p><p><strong>Agruments</strong></p><ul><li><code>prop_method</code> (<code>ImageZono</code>): Solver being used.</li><li><code>model</code>: Neural network model that is to be verified.</li><li><code>input</code> (<code>ImageZonoBound</code>): Input specification supported by <code>ImageZonoBound</code>.</li><li><code>reach</code> (<code>LazySet</code>): Reachable set resulting from the propagation of <code>input</code>    through the <code>model</code>.</li><li><code>output</code> (<code>LazySet</code>) : Set of valid outputs represented with a <code>LazySet</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>ReachabilityResult(:holds, box_reach)</code> if <code>reach</code> is a subset of <code>output</code>,    the function returns <code>:holds</code> with the box approximation (overapproximation    with hyperrectangle) of the <code>reach</code> set.</li><li><code>CounterExampleResult(:unknown)</code> if <code>reach</code> is not a subset of <code>output</code>, but    cannot find a counterexample.</li><li><code>CounterExampleResult(:violated, x)</code> if <code>reach</code> is not a subset of <code>output</code>,    and there is a counterexample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8b1324cb24f97407a1b4d4a8200eed7d5d6d9360/src/solvers/image-zono.jl#L135-L158">source</a></section></article><h2 id="Crown"><a class="docs-heading-anchor" href="#Crown">Crown</a><a id="Crown-1"></a><a class="docs-heading-anchor-permalink" href="#Crown" title="Permalink"></a></h2><h2 id="\\alpha-Crown"><a class="docs-heading-anchor" href="#\\alpha-Crown"><span>$\alpha$</span>-Crown</a><a id="\\alpha-Crown-1"></a><a class="docs-heading-anchor-permalink" href="#\\alpha-Crown" title="Permalink"></a></h2><h2 id="\\beta-Crown"><a class="docs-heading-anchor" href="#\\beta-Crown"><span>$\beta$</span>-Crown</a><a id="\\beta-Crown-1"></a><a class="docs-heading-anchor-permalink" href="#\\beta-Crown" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="propagate.html">« Propagation</a><a class="docs-footer-nextpage" href="attack.html">Attacks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Monday 4 December 2023 15:16">Monday 4 December 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
