<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow · ModelVerification.jl</title><meta name="title" content="Flow · ModelVerification.jl"/><meta property="og:title" content="Flow · ModelVerification.jl"/><meta property="twitter:title" content="Flow · ModelVerification.jl"/><meta name="description" content="Documentation for ModelVerification.jl."/><meta property="og:description" content="Documentation for ModelVerification.jl."/><meta property="twitter:description" content="Documentation for ModelVerification.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ModelVerification.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModelVerification.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">ModelVerification.jl</a></li><li><span class="tocitem">Toolbox Outline</span><ul><li class="is-active"><a class="tocitem" href="toolbox_flow.html">Flow</a><ul class="internal"><li><a class="tocitem" href="#.-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*"><span>1. Creating an instance: <em>what kind of verification problem do you want to solve?</em></span></a></li><li><a class="tocitem" href="#.-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*"><span>2. Verifying the instance: <em>spinning through the branches - where the magic happens!</em></span></a></li><li><a class="tocitem" href="#.-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*"><span>3. Results and how to interpret them: <em>so is my model good to go?</em></span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Problem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="problem.html">Problem Outline</a></li><li><a class="tocitem" href="network.html">Network</a></li><li><a class="tocitem" href="safety_spec.html">Input-Output Specification</a></li></ul></li><li><a class="tocitem" href="branching.html">Branching</a></li><li><a class="tocitem" href="propagate.html">Propagation</a></li><li><a class="tocitem" href="solvers.html">Solvers</a></li><li><a class="tocitem" href="attack.html">Attacks</a></li><li><a class="tocitem" href="utils.html">Helper Functions</a></li></ul></li><li><span class="tocitem">Python Interface</span><ul><li><a class="tocitem" href="nnet_converter.html">NNet Converter</a></li><li><a class="tocitem" href="python_interface.html">Python Interface</a></li></ul></li><li><a class="tocitem" href="existing_implementations.html">Existing Implementations</a></li><li><a class="tocitem" href="about.html">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Toolbox Outline</a></li><li class="is-active"><a href="toolbox_flow.html">Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="toolbox_flow.html">Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/intelligent-control-lab/ModelVerification.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/master/docs/src/toolbox_flow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="toolbox_flow.html#Flow">Flow</a></li><li class="no-marker"><ul><li><a href="toolbox_flow.html#.-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*">1. Creating an instance: <em>what kind of verification problem do you want to solve?</em></a></li><li><a href="toolbox_flow.html#.-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*">2. Verifying the instance: <em>spinning through the branches - where the magic happens!</em></a></li><li><a href="toolbox_flow.html#.-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*">3. Results and how to interpret them: <em>so is my model good to go?</em></a></li></ul></li></ul><p><em>Please note that this page is under construction.</em></p><h1 id="Flow"><a class="docs-heading-anchor" href="#Flow">Flow</a><a id="Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Flow" title="Permalink"></a></h1><p><img src="assets/overview_mvflow.png" alt/></p><p><em>This page serves to explain the overall flow of the toolbox. For examples and explanation on how to use specific verification functions, please refer to the <a href="index.html#tutorials">tutorials</a>.</em> </p><p>In general, verification algorithms follow the paradigm of <em>Branch and Bound</em>. This process can be summarized into three steps:</p><ol><li>split the input set into smaller sets, which we call &quot;branches&quot;,</li><li>propagate the bound through the model for a given branch,</li><li>check whether the bound of the final layer satisfies the output specificaiton.</li></ol><p>Repeat or terminate the process based on the result.</p><p><a href="https://github.com/intelligent-control-lab/ModelVerification.jl">ModelVerification.jl</a> uses a modularized code structure to support various combinations of search methods, split methods, and solvers for a variety of neural network architectures and geometric representations for the safety specifications. After reading through this section, the user should have an overall idea of the flow of the toolbox and the design philosophy behind it. Thanks to the highly modularized structure of the toolbox, the user can add additional functionalities at any layer of the verification process. </p><p><img src="assets/sequence_diagram_MV.png" alt/></p><h3 id="Definition-of-Terms"><a class="docs-heading-anchor" href="#Definition-of-Terms">Definition of Terms</a><a id="Definition-of-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-of-Terms" title="Permalink"></a></h3><p>Here, we define some terms that are unique to the toolbox or are used differently compared to the typical usage.</p><ul><li><strong>Instance</strong>: combination of all the necessary information to define an &quot;instance&quot; of neural network verification problem. This is consisted of: <ul><li><a href="problem.html">problem</a></li><li><a href="solvers.html">solver</a></li><li><a href="branching.html#search">search methods</a></li><li><a href="branching.html#split">split methods</a></li></ul></li><li><strong>Propagation Method</strong>: this is the bound propagation method used for verifying the problem. In other words, it is the choice of term to represent the <a href="solvers.html">&quot;solver&quot;</a>: all the solvers in <a href="https://github.com/intelligent-control-lab/ModelVerification.jl">ModelVerification.jl</a> are represented as a propagation method. However, this is different from the <a href="propagate.html">methods in <code>propagate.jl</code></a>. This will be clearer in the following explanations.</li><li><strong>Model / (Deep) Neural Network / Network</strong>: these terms are used interchangeably and represent the deep neural network (DNN) to be verified.</li><li><strong>Node</strong>: (This is not equivalent to a &quot;neuron&quot; in a traditional deep learning sense.) This refers to a &quot;node&quot; in a computational-graph sense.</li><li><strong>Layer</strong>: (This is not equivalent to a &quot;layer&quot; in a traditional deep learning sense.) This refers to an operation at a node, such as ReLU activation function.</li><li><strong>BaB</strong>: &quot;Branch-and-Bound&quot; is a method that creates a binary tree for the search space where the verification is employed. </li><li><strong>Set vs Bound</strong>: One set is composed of bounds. E.g., for the output reachable set is a union of output bounds. But we use these terms interchangeably throughout the toolbox.</li></ul><h2 id=".-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*"><a class="docs-heading-anchor" href="#.-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*">1. Creating an instance: <em>what kind of verification problem do you want to solve?</em></a><a id=".-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*-1"></a><a class="docs-heading-anchor-permalink" href="#.-Creating-an-instance:-*what-kind-of-verification-problem-do-you-want-to-solve?*" title="Permalink"></a></h2><p>Let&#39;s first create an instance. An instance contains all the information required to run the <a href="toolbox_flow.html#ModelVerification.verify"><code>verify</code></a> function. This function does the heavy-lifting where the verification problem is solved. As long as the user properly defines the problem and solver methods, this is the only function the user has to call. To run <a href="toolbox_flow.html#ModelVerification.verify"><code>verify</code></a>, the user has to provide the following arguments. These collectively define an &quot;instance&quot;:</p><ul><li><a href="branching.html#ModelVerification.SearchMethod"><code>SearchMethod</code></a>: Algorithm for iterating through the branches, such as <code>BFS</code> (breadth-first search) and <code>DFS</code> (depth-first search).</li><li><a href="branching.html#ModelVerification.SplitMethod"><code>SplitMethod</code></a>: Algorithm for splitting an unknown branch into smaller pieces for further refinement. This is also used in the first step of <a href="toolbox_flow.html#ModelVerification.verify"><code>verify</code></a> to populate the branches bank. In other words, it splits the input specification into branches to facilitate the propagation process.</li><li><a href="solvers.html#ModelVerification.PropMethod"><code>PropMethod</code></a>: Solver used to verify the problem, such as <code>Ai2</code> and <code>Crown</code>.</li><li><a href="problem.html#ModelVerification.Problem"><code>Problem</code></a>: Problem to be verified. It consists of a <a href="network.html#ModelVerification.Network"><code>Network</code></a>, and <a href="safety_spec.html">input and output specifications</a>.</li></ul><p>This toolbox design choice allows for extensive customization of methods and solvers by defining different search or split methods. The user simply needs to add their chosen methods in the specific files (<code>search.jl</code> and <code>split.jl</code>), which the solvers will automatically use for the verification process.</p><h3 id="[SearchMethod](@ref)"><a class="docs-heading-anchor" href="#[SearchMethod](@ref)"><a href="branching.html#ModelVerification.SearchMethod"><code>SearchMethod</code></a></a><a id="[SearchMethod](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[SearchMethod](@ref)" title="Permalink"></a></h3><p><code>SearchMethod</code> describes the strategy the solver uses when iterating through the branches. Currently, <a href="https://github.com/intelligent-control-lab/ModelVerification.jl">ModelVerification.jl</a> only supports Breath-first Search (BFS). The solver can exploit parallel analysis of the nodes in the BaB by indicating a <code>batch_size</code> is greater than 1. </p><h3 id="[SplitMethod](@ref)"><a class="docs-heading-anchor" href="#[SplitMethod](@ref)"><a href="branching.html#ModelVerification.SplitMethod"><code>SplitMethod</code></a></a><a id="[SplitMethod](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[SplitMethod](@ref)" title="Permalink"></a></h3><p><code>SplitMethod</code> specifies how many splits and where they are performed on a single node of the BaB. Depending on the <code>SplitMethod</code>, the solver will split either the input space or the ReLU nodes.</p><p>The following split methods are supported:</p><ul><li>Bisectection (<code>Bisect</code>): splits either the input space or the ReLU nodes.</li><li>Branch-and-bound (<code>BaBSR</code>): splits the ReLU nodes.</li></ul><h3 id="[PropMethod](@ref)"><a class="docs-heading-anchor" href="#[PropMethod](@ref)"><a href="solvers.html#ModelVerification.PropMethod"><code>PropMethod</code></a></a><a id="[PropMethod](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[PropMethod](@ref)" title="Permalink"></a></h3><p><code>PropMethod</code> is the solver to be used for the verification.</p><p>The following solvers are supported:</p><ul><li>ExactReach</li><li>Ai2</li><li>ImageStar</li><li>ImageZono</li><li>Crown</li><li><p class="math-container">\[\alpha\]</p>-Crown</li><li><p class="math-container">\[\beta\]</p>-Crown</li></ul><h3 id="[Problem](@ref)"><a class="docs-heading-anchor" href="#[Problem](@ref)"><a href="problem.html#ModelVerification.Problem"><code>Problem</code></a></a><a id="[Problem](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#[Problem](@ref)" title="Permalink"></a></h3><p><code>Problem</code> is composed by the model to be verified and the input &amp; output specifications. Specifically, this part of the &quot;instance&quot; encodes what we want to verify rather than how we achieve the formal verification results.</p><ul><li>For information on how to load or convert models and how they are represented in <a href="https://github.com/intelligent-control-lab/ModelVerification.jl">ModelVerification.jl</a>, please refer <a href="network.html">Network</a>.</li><li>For the different geometric representations for the input and output specifications, please refer <a href="safety_spec.html">Input-Output Specification</a>. </li></ul><h2 id=".-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*"><a class="docs-heading-anchor" href="#.-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*">2. Verifying the instance: <em>spinning through the branches - where the magic happens!</em></a><a id=".-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*-1"></a><a class="docs-heading-anchor-permalink" href="#.-Verifying-the-instance:-*spinning-through-the-branches-where-the-magic-happens!*" title="Permalink"></a></h2><p><a href="toolbox_flow.html#ModelVerification.verify"><code>verify</code></a> is the main function called by <a href="https://github.com/intelligent-control-lab/ModelVerification.jl">ModelVerification.jl</a> to start the verification process of the &quot;instance&quot; provided by the user.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.verify" href="#ModelVerification.verify"><code>ModelVerification.verify</code></a> — <span class="docstring-category">Function</span></header><section><div><p>verify(search<em>method::SearchMethod, split</em>method::SplitMethod,         prop<em>method::PropMethod, problem::Problem;         time</em>out=86400, attack<em>restart=100, collect</em>bound=false,         summary=false, pre_split=nothing)</p><p>This is the main function for verification. It takes in a search method,  a split method, a propagation method, and a problem, and returns a result.  The result is of type <code>ResultInfo</code>, which is a wrapper for the following  <code>Result</code> types: <code>BasicResult</code>, <code>CounterExampleResult</code>, <code>AdversarialResult</code>,  <code>ReachabilityResult</code>, <code>EnumerationResult</code>, or timeout.  For each <code>Result</code>, the <code>status</code> field is either <code>:violated</code>, <code>:verified</code>, or  <code>:unknown</code>. Optional arguments can be passed to the function  to control the timeout, the number of restarts for the attack, whether  to collect the bounds for each branch, whether to print a summary of the  verification process, and whether to pre-split the problem.</p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>SearchMethod</code>): The search method, such as <code>BFS</code>, used to    search through the branches.</li><li><code>split_method</code> (<code>SplitMethod</code>): The split method, such as <code>Bisect</code>, used to    split the branches.</li><li><code>prop_method</code> (<code>PropMethod</code>): The propagation method, such as <code>Ai2</code>, used to    propagate the constraints.</li><li><code>problem</code> (<code>Problem</code>): The problem to be verified - consists of a network,    input set, and output set.</li><li><code>time_out</code> (<code>Int</code>): The timeout in seconds. Defaults to 86400 seconds, or 24    hours. If the timeout is reached, the function returns <code>:timeout</code>.</li><li><code>attack_restart</code> (<code>Int</code>): The number of restarts for the attack. Defaults to 100.</li><li><code>collect_bound</code> (<code>Bool</code>): Whether to collect the bounds for each branch.</li><li><code>summary</code> (<code>Bool</code>): Whether to print a summary of the verification process.</li><li><code>pre_split</code>: A function that takes in a <code>Problem</code> and returns a    <code>Problem</code> with the input set pre-split. Defaults to <code>nothing</code>.</li><li><code>search_adv_bound</code> (<code>Bool</code>): Whether to search the maximal input bound that can    pass the verification (get <code>:holds</code>) with the given setting.</li></ul><p><strong>Returns</strong></p><ul><li>The result is <code>ResultInfo</code>, the <code>status</code> field is either <code>:violated</code>, <code>:verified</code>,    <code>:unknown</code>, or <code>:timeout</code>. The info is a dictionary that contains other information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8d4f2ecc942b9d3eb131f3f5ff5586223c5bc909/src/ModelVerification.jl#L175-L214">source</a></section></article><h3 id="prepare_problem"><a class="docs-heading-anchor" href="#prepare_problem"><code>prepare_problem</code></a><a id="prepare_problem-1"></a><a class="docs-heading-anchor-permalink" href="#prepare_problem" title="Permalink"></a></h3><p>The first step of <a href="toolbox_flow.html#ModelVerification.verify"><code>verify</code></a> is <code>prepare_problem</code> which preprocesses the <code>Problem</code> into a form that is compatible with the verification solver. Its main two functionalities are:</p><ol><li>Retrieves the model information and stores it inside <code>model_info</code>,</li><li>Exploits the <code>init_bound</code> function which returns the geometry representation that matches the solver requirements. For instance, since CROWN is a backward propagation method, the <code>init_bound</code> function returns the geometry used to encode the output specification. </li></ol><p>The result of <code>prepare_problem</code> are two variables:</p><ol><li><code>model_info</code>: structure that contains information about the <code>Flux</code> model,</li><li><code>prepared_problem</code>: <code>Problem</code> with a processed input-output specification.</li></ol><h3 id="search_branches"><a class="docs-heading-anchor" href="#search_branches"><code>search_branches</code></a><a id="search_branches-1"></a><a class="docs-heading-anchor-permalink" href="#search_branches" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.search_branches-Tuple{BFS, Vararg{Any, 4}}" href="#ModelVerification.search_branches-Tuple{BFS, Vararg{Any, 4}}"><code>ModelVerification.search_branches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search_branches(search_method::BFS, split_method, prop_method, 
                problem, model_info)</code></pre><p>Searches through the branches in the branch bank, <code>branches</code>, until the branch  bank is empty or time out. In each iteration (up to <code>search_method.max_iter</code>),  a batch of unverified branches will be extracted from the branch bank. Then, the  following is performed to verify the model:</p><ol><li><code>prepare_method</code> initializes the bound of the start node of the </li></ol><p>computational graph based on the geometric representation and corresponding  solver.</p><ol><li><code>propagate</code> propagates the bound from the start node to the end node of the </li></ol><p>computational graph.</p><ol><li><code>process_bound</code> processes the bounds resulting from the propagation </li></ol><p>accordingly to the solver, <code>prop_method</code>. For example, for Ai2-based methods,  <code>process_bound</code> simply returns the bounds from the <code>propagate</code> step. However,  for Crown-based methods, <code>process_bound</code> post-processes the bounds.</p><ol><li><code>check_inclusion</code> decides whether the bound of the end node, the reachable </li></ol><p>set, satisfies the output specification or not.      1. If not, i.e., <code>:violated</code>, then the counterexample is returned and the      verification process terminates.     2. If yes, i.e., <code>:holds</code>, then the current branch is verified and the      function starts Step 1 again for the next branch, if any.     3. If unknown, i.e., <code>:unknown</code>, further refinement of the problem is      preformed using <code>split_branch</code>, which divides the current branch into      smaller pieces and puts them into the branch bank for further verification.      Such <code>:unknown</code> status results due to the overapproximation introduced in      the verification process.</p><p>If the branch bank is empty after going through <code>search_method.max_iter</code> number  of verification procedures, the model is verified to be valid and returns  <code>:holds</code>. If the branch bank is not empty, the function returns <code>:unknown</code>.</p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>BFS</code>): Breadth-first Search method for iteratively going    through the branches.</li><li><code>split_method</code>: Method for splitting the branches when further refinement is    needed. This inclueds methods such as <code>Bisect</code> and <code>BaBSR</code>.</li><li><code>prop_method</code>: Propagation method used for the verification process. This is    one of the solvers used to verify the given model.</li><li><code>problem</code>: Problem definition for model verification.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>collect_bound</code>(optional): Default is false, whether return the verified    bound.</li><li><code>pre_split</code>(optional): nothing, the number of split before any propagation.    This is particularly useful for large input set that could lead to memory    overflow.</li></ul><p><strong>Returns</strong></p><ul><li><code>BasicResult(:holds)</code> if all the reachable sets are within the corresponding    output specifications in the batch.</li><li><code>BasicResult(:unknown)</code> if the function failed to make a firm decision within    the given time. This is due to the overapproximation introduced in the    verification process.</li><li><code>CounterExampleResult(:violated, x)</code> if a reachable set is not within the    corresponding output specification and there is a counterexample found.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8d4f2ecc942b9d3eb131f3f5ff5586223c5bc909/src/branching/search.jl#L55-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.advance_split-Tuple{Int64, BFS, Vararg{Any, 4}}" href="#ModelVerification.advance_split-Tuple{Int64, BFS, Vararg{Any, 4}}"><code>ModelVerification.advance_split</code></a> — <span class="docstring-category">Method</span></header><section><div><p>advance<em>split(max</em>iter::Int, search<em>method::BFS, split</em>method, prop<em>method,                problem, model</em>info)</p><p>Performs the splitting of the branches in the branch bank, <code>branches</code>, for a  <code>max_iter</code> number of times. This is used in the <code>search_branches</code> function as  serves as the first step of the verification process: populating the <code>branches</code>  bank with initial branches.</p><p><strong>Arguments</strong></p><ul><li><code>max_iter</code> (<code>Int</code>): Maximum number of iterations to split the input   specification.</li><li><code>search_method</code> (<code>BFS</code>): Breadth-first Search method for iteratively going    through the branches.</li><li><code>split_method</code>: Method for splitting the branches for the initial    population of the branch bank. This inclueds methods such as <code>Bisect</code>.</li><li><code>prop_method</code>: Propagation method used for the verification process. This is    one of the solvers used to verify the given model.</li><li><code>problem</code>: Problem definition for model verification. Include the model and    input and output specifications.</li><li><code>model_info</code>: Structure containing the information of the neural network to be   verified.</li></ul><p><strong>Returns</strong></p><ul><li><code>branches</code>: Array of branches to be verified, split from the initial input    specification.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8d4f2ecc942b9d3eb131f3f5ff5586223c5bc909/src/branching/search.jl#L18-L44">source</a></section></article><p><code>search_branches</code> is the core function used for the verification process. It consists of several subfunctions that we are going to summarize in the following. At first, the function initializes the branch bank for the entire safety property&#39;s input-output domain. This can be done by <code>advance_split</code>, which splits the input-output domain using the given split method. Thus, each &quot;branch&quot; is a subpart of the input-output domain. The function seeks to verify all the branches and if it cannot provide a result (i.e., we obtain an <code>:unknown</code> answer), the function proceeds to split branch for a more refined verification process.. If the function verifies all the branches within the given maximum number of iterations, then we obtain a <code>:holds</code> answer. If the function finds any branch that does not satisfy the safety property, then it returns <code>:violated</code>.</p><p>For each iteration, i.e., for each branch, the function calls the following subfunctions to verify the branch:</p><ol><li><p><code>prepare_method</code>: this function retrieves all the information to perform either the forward or backward propagation of the input domain of the branch.  The result is stored in two variables called <code>batch_out_spec</code>, <code>batch_info</code>, which contain the batch of the outputs and a dictionary containing all the information of each node in the model. <code>prepare_method</code> calls the following functions in sequence:</p><ul><li><code>init_propagation</code>: Differentiates between <code>ForwardProp</code> and <code>BackwardProp</code>. If the solver being used employs a forward propagation method, then we start propagating from the input nodes. If it employs a backward propagation method, then we start from the output nodes.</li><li><code>init_batch_bound</code>: Calls <code>init_bound</code>, which returns either the input or output geometry representation based on the type of propagation to perform.</li></ul></li><li><p>The result of the previous function is then used in the <a href="propagate.html#ModelVerification.propagate"><code>propagate</code></a> function. This function propagates the starting bounds through the model using the specified propagation method, i.e., the solver. The <code>propagate</code> function acts as the overall logic for propagating the branch through the model and performs the propagation based on the layer operation (linear, ReLU, etc.) and the geometric representation for the bounds. The user can add additional layer operators in the <code>propagate/operators</code> folder. Moreover, the toolbox supports skip connections. The <code>propagate</code> function returns <code>batch_bound</code>, the bound of the output node, and an augmented <code>batch_info</code> dictionary with the output bound information added.</p></li><li><p>Now, <code>process_bounds</code> returns the reachable bounds obtained from the <code>propagate</code> function. Depending on the solver, the reachable bounds may be post-processed to optimized the verification procedure.</p></li><li><p>Finally, <code>check_inclusion</code> checks for the overlapping between the reachable bounds obtained from the propagation and the safety property&#39;s output bounds. Since we are using overapproximation of the output reachable set, the only case in which we can obtain <code>:holds</code> result is when the output reachable set is fully contained in the user-specified output set. On the other hand, the <code>:violated</code> result is only possible when the sets are completely disjoint. In all other cases, we have an <code>:unknown</code> answer and we proceed with the branch splitting method below to populate the branch bank.</p></li><li><p><code>split_branch</code> is used to split the current branch with <code>:unknown</code> answer into two separate branches which are split based on the <code>split_method</code>. The sub-branches are then added to the &quot;branches&quot; bank.</p></li></ol><p>We continue this loop until either get a <code>:violated</code> result, a <code>:hold</code> result for all the branches, or reach the maximum number of iterations.</p><h3 id="search_adv_input_bound"><a class="docs-heading-anchor" href="#search_adv_input_bound"><code>search_adv_input_bound</code></a><a id="search_adv_input_bound-1"></a><a class="docs-heading-anchor-permalink" href="#search_adv_input_bound" title="Permalink"></a></h3><p>If the verification result from <code>verify</code> is not <code>:holds</code>, i.e., either <code>:unknown</code> or <code>:violated</code>, then <a href="toolbox_flow.html#ModelVerification.search_adv_input_bound"><code>search_adv_input_bound</code></a> searches for the maximul input bound that can pass the verification, i.e., retrieves <code>:holds</code>, with the given setting. This information is passed to the <a href="problem.html#ModelVerification.ResultInfo"><code>ResultInfo</code></a> as a dictionary field so that the user can check.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ModelVerification.search_adv_input_bound" href="#ModelVerification.search_adv_input_bound"><code>ModelVerification.search_adv_input_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">search_adv_input_bound(search_method::SearchMethod, 
                       split_method::SplitMethod, 
                       prop_method::PropMethod, 
                       problem::Problem;
                       eps = 1e-3)</code></pre><p>This function is used to search the maximal input bound that can pass the  verification (get <code>:holds</code>) with the given setting. The search is done by  binary search on the input bound that is scaled by the given ratio. This  function is called in <code>verify</code> function when <code>search_adv_bound</code> is set to  <code>true</code> and the initial verification result is <code>:unknown</code> or <code>:violated</code>. </p><p><strong>Arguments</strong></p><ul><li><code>search_method</code> (<code>SearchMethod</code>): The search method, such as <code>BFS</code>, used to    search through the branches. </li><li><code>split_method</code> (<code>SplitMethod</code>): The split method, such as <code>Bisect</code>, used to    split the branches.</li><li><code>prop_method</code> (<code>PropMethod</code>): The propagation method, such as <code>Ai2</code>, used to    propagate the constraints.</li><li><code>problem</code> (<code>Problem</code>): The problem to be verified - consists of a network,    input set, and output set.</li><li><code>eps</code> (<code>Real</code>): The precision of the binary search. Defaults to 1e-3. </li></ul><p><strong>Returns</strong></p><ul><li>The maximal input bound that can pass the verification (get <code>:holds</code>) with    the given setting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/8d4f2ecc942b9d3eb131f3f5ff5586223c5bc909/src/ModelVerification.jl#L238-L265">source</a></section></article><h2 id=".-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*"><a class="docs-heading-anchor" href="#.-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*">3. Results and how to interpret them: <em>so is my model good to go?</em></a><a id=".-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*-1"></a><a class="docs-heading-anchor-permalink" href="#.-Results-and-how-to-interpret-them:-*so-is-my-model-good-to-go?*" title="Permalink"></a></h2><p>Once the <code>verify</code> function is over, it returns a <a href="problem.html#ModelVerification.ResultInfo"><code>ResultInfo</code></a> that contains the <code>status</code> (either <code>:hold</code>, <code>:violated</code>, <code>:unknown</code>) and a dictionary that contains any other additional information needed to understand the verification results in detail, such as the verified bounds, adversarial input bounds, etc.</p><p>The following are the <code>Result</code> types used interally for the toolbox to differentiate between different verification results. The result is either a <code>BasicResult</code>, <code>CounterExampleResult</code>,  <code>AdversarialResult</code>, <code>ReachabilityResult</code>, or <code>EnumerationResult</code> (to-be-supported). The <code>status</code> field is either <code>:violated</code>, <code>:holds</code>, or <code>:unknown</code>.</p><table><tr><th style="text-align: right">Output result</th><th style="text-align: center">Explanation</th></tr><tr><td style="text-align: right">[<code>BasicResult::holds</code>]</td><td style="text-align: center">The input-output constraint is always satisfied.</td></tr><tr><td style="text-align: right">[<code>BasicResult::violated</code>]</td><td style="text-align: center">The input-output constraint is violated, i.e., it exists a single point in the input constraint that violates the property.</td></tr><tr><td style="text-align: right">[<code>BasicResult::unknown</code>]</td><td style="text-align: center">Could not be determined if the property holds due to timeout in the computation.</td></tr><tr><td style="text-align: right">[<code>CounterExampleResult</code>]</td><td style="text-align: center">Like BasicResult, but also returns a counter<em>example if one is found (if status = :violated). The counter</em>example is a point in the input set that, after the NN, lies outside the output constraint set.</td></tr><tr><td style="text-align: right">[<code>AdversarialResult</code>]</td><td style="text-align: center">Like BasicResult, but also returns the maximum allowable disturbance in the input (if status = :violated).</td></tr><tr><td style="text-align: right">[<code>ReachabilityResult</code>]</td><td style="text-align: center">Like BasicResult, but also returns the output reachable set given the input constraint (if status = :violated).</td></tr><tr><td style="text-align: right">[<code>EnumerationResult</code>]</td><td style="text-align: center">Set of all the (un)safe regions in the safety property&#39;s domain.</td></tr></table><p>For more information, please refer to <a href="problem.html#result"><em>Output (Verification Results)</em></a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« ModelVerification.jl</a><a class="docs-footer-nextpage" href="problem.html">Problem Outline »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Monday 11 December 2023 14:04">Monday 11 December 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
