<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Propagation · ModelVerification.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="ModelVerification.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ModelVerification.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">ModelVerification.jl</a></li><li><span class="tocitem">Toolbox Outline</span><ul><li><a class="tocitem" href="toolbox_flow.html">Flow</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Problem</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="problem.html">Problem Outline</a></li><li><a class="tocitem" href="network.html">Network</a></li><li><a class="tocitem" href="safety_spec.html">Input-Output Specification</a></li></ul></li><li><a class="tocitem" href="branching.html">Branching</a></li><li class="is-active"><a class="tocitem" href="propagate.html">Propagation</a><ul class="internal"><li><a class="tocitem" href="#Bivariate"><span>Bivariate</span></a></li><li><a class="tocitem" href="#Convolution"><span>Convolution</span></a></li><li><a class="tocitem" href="#Dense"><span>Dense</span></a></li><li><a class="tocitem" href="#Identity"><span>Identity</span></a></li><li><a class="tocitem" href="#Normalise"><span>Normalise</span></a></li><li><a class="tocitem" href="#ReLU"><span>ReLU</span></a></li><li><a class="tocitem" href="#Stateless"><span>Stateless</span></a></li></ul></li><li><a class="tocitem" href="solvers.html">Solvers</a></li><li><a class="tocitem" href="attack.html">Attacks</a></li><li><a class="tocitem" href="utils.html">Helper Functions</a></li></ul></li><li><span class="tocitem">Python Interface</span><ul><li><a class="tocitem" href="nnet_converter.html">NNet Converter</a></li><li><a class="tocitem" href="python_interface.html">Python Interface</a></li></ul></li><li><a class="tocitem" href="existing_implementations.html">Existing Implementations</a></li><li><a class="tocitem" href="about.html">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Toolbox Outline</a></li><li class="is-active"><a href="propagate.html">Propagation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="propagate.html">Propagation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/main/docs/src/propagate.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul></ul><h1 id="Propagation"><a class="docs-heading-anchor" href="#Propagation">Propagation</a><a id="Propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Propagation" title="Permalink"></a></h1><p>Functions for propagating the bound through the model (from start nodes to the end nodes) for a given branch. For a forward propagation method (<code>ForwardProp</code>), the start nodes are the input nodes of the computational graph and the end nodes are the output nodes. For a backward propagation method (<code>BackwardProp</code>), the start nodes are the output nodes and the end nodes are the input nodes. We use BFS (Breadth-first Search) to iterate through the computational graph and propagate the bounds from nodes to nodes.</p><p>The <code>propagate\propagate.jl</code> module defines algorithms for propagating bounds from input to output, for both forward propagation and backward propagation.</p><p>The <code>propagate\operators</code> folder contains specific propagation algorithms for different operators, such as ReLU, Dense, Identity, Convolution, Bivariate, etc.</p><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate" href="#ModelVerification.propagate"><code>ModelVerification.propagate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propagate(prop_method::PropMethod, model_info, batch_info)</code></pre><p>Propagates through the model using the specified <code>prop_method</code>.  The propagation algorithm is as follows:</p><ol><li>Add the connecting nodes of the start nodes, i.e., nodes after the start </li></ol><p>nodes, into a queue.</p><ol><li>While the queue is not empty:<ol><li>Pop a node from the queue.</li><li>For each node connected from the current node, i.e., for each output   node:<ol><li>Increment the visit count to the output node.</li><li>If the visit count equals the number of nodes connected from the   output node, i.e., visit count == previous nodes of the output node,   add the output node to the queue.</li></ol></li><li>Propagate through the current node accordingly.</li><li>Add information about the bound of the node to <code>batch_info</code>.</li></ol></li><li>Return the bound of the output node(s).</li></ol><p>In step 2(1)(2), the function adds the output node to the queue since all the  previous nodes of the output node have been processed. Thus, the output node is  now the node of interest. In step 2(3), the propagation works based on the  propagation method (<code>prop_method</code>), which depends on the geometric  representation of the safety specifications and the activation function of each  layer.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>PropMethod</code>): Propagation method used for the verification    process. This is one of the solvers used to verify the given model.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: Bound of the output node, i.e., the final bound.</li><li><code>batch_info</code>: Same as the input <code>batch_info</code>, with additional information on    the bound of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L1-L39">source</a></section><section><div><pre><code class="nohighlight hljs">propagate(prop_method::ODEProp, model_info, batch_info)</code></pre><p>Propagates reachable set with a ODE integrator.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ODEProp</code>): ODE integration method used for the verification    process.</li><li><code>model_info</code>: The neural ODE flux model. It is different from model_info in propagate()   of other, which is a Model structure containing the general computational graph.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: Bound of the output node, i.e., the final bound.</li><li><code>batch_info</code>: Same as the input <code>batch_info</code>, with additional information on    the bound of each node in the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate_neural_ode.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_skip_method-Tuple{ModelVerification.ForwardProp, Any, Any, Any}" href="#ModelVerification.propagate_skip_method-Tuple{ModelVerification.ForwardProp, Any, Any, Any}"><code>ModelVerification.propagate_skip_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_skip_method(prop_method::ForwardProp, model_info, 
                      batch_info, node)</code></pre><p>This function propagates the two sets of bounds of the preceding nodes from the  provided <code>node</code> using the specified forward propagation method and layer  operation. It invokes <code>propagate_skip_batch</code>, which subsequently calls   <code>propagate_skip</code>. The function identifies the two previous nodes from the given <code>node</code> in the computational graph, <code>model_info</code>, their bounds, and the layer  operation of the node. Then, <code>propagate_skip</code> is invoked.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Forward propagation method used for the    verification process. This is one of the solvers used to verify the given    model.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li><li><code>node</code>: The current node to be propagated through.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: List of reachable bounds after propagating the two sets of   bounds in <code>batch_reach</code> through the given <code>node</code>, following the propagation    method and the layer operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L209-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_skip_method-Tuple{ModelVerification.BackwardProp, Any, Any, Any}" href="#ModelVerification.propagate_skip_method-Tuple{ModelVerification.BackwardProp, Any, Any, Any}"><code>ModelVerification.propagate_skip_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_skip_method(prop_method::BackwardProp, model_info, 
                      batch_info, node)</code></pre><p>This function propagates the two sets of bounds of the next nodes from the  provided <code>node</code> using the specified backward propagation method and layer  operation. It invokes <code>propagate_skip_batch</code>, which subsequently calls   <code>propagate_skip</code>. The function identifies the two next nodes from the given <code>node</code> in the computational graph, <code>model_info</code>, their bounds, and the layer  operation of the node. Then, <code>propagate_skip</code> is invoked.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BackwardProp</code>): Backward propagation method used for the    verification process. This is one of the solvers used to verify the given    model.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li><li><code>node</code>: The current node to be propagated through.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: List of reachable bounds after propagating the two sets of   bounds in <code>batch_reach</code> through the given <code>node</code>, following the propagation    method and the layer operation.                          </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L244-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_method-Tuple{ModelVerification.ForwardProp, Any, Any, Any}" href="#ModelVerification.propagate_layer_method-Tuple{ModelVerification.ForwardProp, Any, Any, Any}"><code>ModelVerification.propagate_layer_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_method(prop_method::ForwardProp, model_info, batch_info, node)</code></pre><p>This function propagates the bounds of the preceding node from the provided node  using the specified forward propagation method and layer operation. It invokes  <code>propagate_layer_batch</code>, which subsequently calls either  <code>propagate_layer_batch</code> or <code>propagate_layer_batch</code>. The function identifies the  previous node from the given node in the computational graph, <code>model_info</code>, its  bound, and the layer operation of the node. Then, <code>propagate_layer_batch</code>  ascertains if the layer operation is linear or includes activation functions  like ReLU. Depending on this, <code>propagate_layer_batch</code> or <code>propagate_layer_batch</code>  is invoked.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): The forward propagation method employed for    verification. It is one of the solvers used to validate the specified model.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li><li><code>node</code>: The current node to be propagated through.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: List of reachable bounds after propagating the set of input    bounds of the given <code>node</code>, following the propagation method and the linear    layer operation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L287-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_method-Tuple{ModelVerification.BackwardProp, Any, Any, Any}" href="#ModelVerification.propagate_layer_method-Tuple{ModelVerification.BackwardProp, Any, Any, Any}"><code>ModelVerification.propagate_layer_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_method(prop_method::BackwardProp, model_info, batch_info, node)</code></pre><p>This function propagates the bounds of the next node from the provided node  using the specified forward propagation method and layer operation. It invokes  <code>propagate_layer_batch</code>, which subsequently calls either  <code>propagate_layer_batch</code> or <code>propagate_layer_batch</code>. The function identifies the  next node from the given node in the computational graph, <code>model_info</code>, its  bound, and the layer operation of the node. Then, <code>propagate_layer_batch</code>  ascertains if the layer operation is linear or includes activation functions  like ReLU. Depending on this, <code>propagate_layer_batch</code> or <code>propagate_layer_batch</code>  is invoked.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BackwardProp</code>): Backward propagation method used for the    verification process. This is one of the solvers used to verify the given    model.</li><li><code>model_info</code>: Structure containing the information of the neural network to be    verified.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li><li><code>node</code>: The current node to be propagated through.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_bound</code>: List of reachable bounds after propagating the set of bounds in    <code>batch_reach</code> through the given <code>node</code>, following the propagation method and    the linear layer operation.</li><li><code>nothing</code> if the given <code>node</code> is a starting node of the model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L334-L361">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>propagate_linear_batch(prop_method::ForwardProp, layer, batch_reach::AbstractArray, batch_info)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>propagate_act_batch(prop_method::ForwardProp, σ, batch_reach::AbstractArray, batch_info)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_skip_batch-Tuple{ModelVerification.ForwardProp, Any, AbstractArray, AbstractArray, Any}" href="#ModelVerification.propagate_skip_batch-Tuple{ModelVerification.ForwardProp, Any, AbstractArray, AbstractArray, Any}"><code>ModelVerification.propagate_skip_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_skip_batch(prop_method::ForwardProp, layer, 
                     batch_reach1::AbstractArray, 
                     batch_reach2::AbstractArray, 
                     batch_info)</code></pre><p>Propagates each combination of the bounds from the <code>batch_reach1</code> and  <code>batch_reach2</code> arrays with the given forward propagation method, <code>prop_method</code>,  through a skip connection. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Forward propagation method used for the    verification process. This is one of the solvers used to verify the given    model.</li><li><code>layer</code>: Identifies what type of operation is done at the layer. Here&#39;s a    bivariate operation is mainly used.</li><li><code>batch_reach1</code> (<code>AbstractArray</code>): First list of input specifications, i.e.,    bounds, to be propagated through the given <code>layer</code>. This is the list of    bounds given by the first of the two previous nodes.</li><li><code>batch_reach2</code> (<code>AbstractArray</code>): Second list of input specifications, i.e.,    bounds, to be propagated through the given <code>layer</code>. This is the list of    bounds given by the second of the two previous nodes.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>batch_reach_info</code>: List of reachable bounds after propagating the    bounds in <code>batch_reach1</code> and <code>batch_reach2</code> through the given <code>layer</code>,    following the propagation method and the layer operation.                         </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L399-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.is_activation-Tuple{Any}" href="#ModelVerification.is_activation-Tuple{Any}"><code>ModelVerification.is_activation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_activation(l)</code></pre><p>Returns true if the given layer <code>l</code> is an activation layer.</p><p><strong>Arguments</strong></p><ul><li><code>l</code>: Layer.</li></ul><p><strong>Returns</strong></p><ul><li>True if <code>l</code> is activation layer.</li><li>False otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L433-L444">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>propagate_layer_batch(prop_method, layer, batch_bound, batch_info)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>enqueue_nodes!(prop_method::ForwardProp, queue, model_info)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>enqueue_nodes!(prop_method::BackwardProp, queue, model_info)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.output_node-Tuple{ModelVerification.ForwardProp, Any}" href="#ModelVerification.output_node-Tuple{ModelVerification.ForwardProp, Any}"><code>ModelVerification.output_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_node(prop_method::ForwardProp, model_info)</code></pre><p>Returns the final nodes of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.next_nodes-Tuple{ModelVerification.ForwardProp, Any, Any}" href="#ModelVerification.next_nodes-Tuple{ModelVerification.ForwardProp, Any, Any}"><code>ModelVerification.next_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_nodes(prop_method::ForwardProp,  model_info, node)</code></pre><p>Returns the next nodes of the <code>node</code> for <code>ForwardProp</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.next_nodes-Tuple{ModelVerification.BackwardProp, Any, Any}" href="#ModelVerification.next_nodes-Tuple{ModelVerification.BackwardProp, Any, Any}"><code>ModelVerification.next_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">next_nodes(prop_method::BackwardProp, model_info, node)</code></pre><p>Returns the previous nodes of the <code>node</code> for <code>BackwardProp</code> methods. Since this  is for <code>BackwardProp</code> methods, the previous nodes are the &quot;next&quot; nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.prev_nodes-Tuple{ModelVerification.ForwardProp, Any, Any}" href="#ModelVerification.prev_nodes-Tuple{ModelVerification.ForwardProp, Any, Any}"><code>ModelVerification.prev_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prev_nodes(prop_method::ForwardProp,  model_info, node)</code></pre><p>Returns the previous nodes of the <code>node</code> for <code>ForwardProp</code> methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.prev_nodes-Tuple{ModelVerification.BackwardProp, Any, Any}" href="#ModelVerification.prev_nodes-Tuple{ModelVerification.BackwardProp, Any, Any}"><code>ModelVerification.prev_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prev_nodes(prop_method::BackwardProp, model_info, node)</code></pre><p>Returns the next nodes of the <code>node</code> for <code>BackwardProp</code> methods. Since this is  for <code>BackwardProp</code> methods, the next nodes are the &quot;previous&quot; nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.all_nexts_in-NTuple{4, Any}" href="#ModelVerification.all_nexts_in-NTuple{4, Any}"><code>ModelVerification.all_nexts_in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_nexts_in(prop_method, model_info, output_node, cnt)</code></pre><p>Returns true if all of the next nodes of the <code>output_node</code> have been visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L180-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.all_prevs_in-NTuple{4, Any}" href="#ModelVerification.all_prevs_in-NTuple{4, Any}"><code>ModelVerification.all_prevs_in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_prevs_in(prop_method, model_info, output_node, cnt)</code></pre><p>Returns true if the <code>output_node</code> has been visited from all the previous nodes. This function checks if all possible connections to the <code>output_node</code> has been  made in the propagation procedure. For example, given a node X, say that there are 5 different nodes that are  mapped to X. Then, if the node X has been visited 5 times, i.e., <code>cnt</code> == 5,  it means that all the previous nodes of X has been outputted to X.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/propagate.jl#L187-L196">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>has_two_reach_node(prop_method, model_info, node)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Bivariate"><a class="docs-heading-anchor" href="#Bivariate">Bivariate</a><a id="Bivariate-1"></a><a class="docs-heading-anchor-permalink" href="#Bivariate" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_skip-Tuple{Any, typeof(+), ModelVerification.ImageStarBound, ModelVerification.ImageStarBound, Any}" href="#ModelVerification.propagate_skip-Tuple{Any, typeof(+), ModelVerification.ImageStarBound, ModelVerification.ImageStarBound, Any}"><code>ModelVerification.propagate_skip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_skip(prop_method, layer::typeof(+), bound1::ImageStarBound, 
               bound2::ImageStarBound, batch_info)</code></pre><p>Propagate the bounds of the two input layers to the output layer for skip  connection. The output layer is of type <code>ImageStarBound</code>. The input layers&#39;  centers, generators, and constraints are concatenated to form the output layer&#39;s  center, generators, and constraints.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>PropMethod</code>): The propagation method used for the verification </li></ul><p>problem.</p><ul><li><code>layer</code> (<code>typeof(+)</code>): The layer operation to be used for propagation.</li><li><code>bound1</code> (<code>ImageStarBound</code>): The bound of the first input layer.</li><li><code>bound2</code> (<code>ImageStarBound</code>): The bound of the second input layer.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The bound of the output layer represented in <code>ImageStarBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/bivariate.jl#L53-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_skip-Tuple{Any, typeof(+), ModelVerification.ImageZonoBound, ModelVerification.ImageZonoBound, Any}" href="#ModelVerification.propagate_skip-Tuple{Any, typeof(+), ModelVerification.ImageZonoBound, ModelVerification.ImageZonoBound, Any}"><code>ModelVerification.propagate_skip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_skip(prop_method, layer::typeof(+), bound1::ImageZonoBound, 
               bound2::ImageZonoBound, batch_info)</code></pre><p>Propagate the bounds of the two input layers to the output layer for skip  connection. The output layer is of type <code>ImageZonoBound</code>. The input layers&#39;  centers and generators are concatenated to form the output layer&#39;s center and generators.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>PropMethod</code>): The propagation method used for the verification    problem.</li><li><code>layer</code> (<code>typeof(+)</code>): The layer operation to be used for propagation.</li><li><code>bound1</code> (<code>ImageZonoBound</code>): The bound of the first input layer.</li><li><code>bound2</code> (<code>ImageZonoBound</code>): The bound of the second input layer.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The bound of the output layer represented in <code>ImageZonoBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/bivariate.jl#L1-L20">source</a></section></article><h2 id="Convolution"><a class="docs-heading-anchor" href="#Convolution">Convolution</a><a id="Convolution-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.bound_layer-Tuple{Flux.Conv{2, 4, typeof(identity), Array{Float32, 4}, Vector{Float32}}, Vararg{AbstractArray, 4}}" href="#ModelVerification.bound_layer-Tuple{Flux.Conv{2, 4, typeof(identity), Array{Float32, 4}, Vector{Float32}}, Vararg{AbstractArray, 4}}"><code>ModelVerification.bound_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bound_layer(layer::Conv{2, 4, typeof(identity), 
                        Array{Float32, 4}, Vector{Float32}}, 
            lower_weight::AbstractArray, upper_weight::AbstractArray, 
            lower_bias::AbstractArray, upper_bias::AbstractArray)</code></pre><p>Propagates the bounds of weight and bias through a convolutional layer. It  applies the convolution operation with <code>Conv</code> to the weight and bias bounds: <code>upper_weight</code>, <code>lower_weight</code>, <code>upper_bias</code>, and <code>lower_bias</code>. </p><p><strong>Arguments</strong></p><ul><li><code>layer</code> (<code>Conv</code>): The convolutional layer to be used for propagation.</li><li><code>lower_weight</code> (AbstractArray): The lower bound of the weight.</li><li><code>upper_weight</code> (AbstractArray): The upper bound of the weight.</li><li><code>lower_bias</code> (AbstractArray): The lower bound of the bias.</li><li><code>upper_bias</code> (AbstractArray): The upper bound of the bias.</li></ul><p><strong>Returns</strong></p><ul><li>The bounds of the weight and bias after convolution operation represented in    a tuple of [lower<em>weight, lower</em>bias, upper<em>weight, upper</em>bias].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L444-L464">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.bound_onside-Tuple{Flux.Conv{2, 4, typeof(identity), Array{Float32, 4}, Vector{Float32}}, AbstractArray, AbstractArray}" href="#ModelVerification.bound_onside-Tuple{Flux.Conv{2, 4, typeof(identity), Array{Float32, 4}, Vector{Float32}}, AbstractArray, AbstractArray}"><code>ModelVerification.bound_onside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bound_onside(layer::Conv{2, 4, typeof(identity), 
                        Array{Float32, 4}, Vector{Float32}}, 
             conv_input_size::AbstractArray, batch_reach::AbstractArray)</code></pre><p>Transforms the batch reachable set to the input size of the convolutional layer  using a <code>ConvTranspose</code> layer. First, it extracts the layer properties such as  <code>weight</code>, <code>bias</code>, and <code>stride</code>. Then, it computes the output bias by summing  over the batch reach and multiplying by the bias. Then, it flips the weights  horizontally and vertically. Then, it computes the padding needed for the output  based on the input size and the convolutional layer properties. Then, it creates  a <code>ConvTranspose</code> layer with the calculated parameters and applies it to the  batch reach. If additional padding is needed, it pads the output using the  <code>PaddedView</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code> (<code>Conv</code>): The convolutional layer to be used for propagation.</li><li><code>conv_input_size</code> (AbstractArray): The size of the input to the convolutional    layer.</li><li><code>batch_reach</code> (AbstractArray): The batch reachable set of the input to the    convolutional layer.</li></ul><p><strong>Returns</strong></p><ul><li>The batch reachable set and batch bias in dimension equal to the input size of    the convolutional layer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L329-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.conv_bound_oneside-NTuple{9, Any}" href="#ModelVerification.conv_bound_oneside-NTuple{9, Any}"><code>ModelVerification.conv_bound_oneside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conv_bound_oneside(weight, bias, stride, pad, dilation, groups, size_before_conv,size_after_conv, batch_size)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L680-L683">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.convtrans_bound_oneside-NTuple{9, Any}" href="#ModelVerification.convtrans_bound_oneside-NTuple{9, Any}"><code>ModelVerification.convtrans_bound_oneside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convtrans_bound_oneside(weight, bias, stride, pad, dilation, groups, size_before_conv,size_after_conv, batch_size)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L774-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.interval_propagate" href="#ModelVerification.interval_propagate"><code>ModelVerification.interval_propagate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interval_propagate(layer::Conv{2, 4, typeof(identity), 
                               Array{Float32, 4}, Vector{Float32}}, 
                   interval, C = nothing)</code></pre><p>Propagates the interval bounds through a convolutional layer. This is used in  the interval arithmetic for neural network verification, where the goal is to  compute the range of possible output values given a range of input values,  represented with <code>interval</code>. It applies the convolution operation with <code>Conv</code>  to the center of the interval and the deviation of the interval.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code> (<code>Conv</code>): The convolutional layer to be used for propagation.</li><li><code>interval</code> (Tuple): The interval bounds of the input to the convolutional    layer.</li><li><code>C</code> (nothing): Optional argument for the center of the interval, default is    nothing.</li></ul><p><strong>Returns</strong></p><ul><li>The interval bounds after convolution operation represented in an array of    [lower, upper, C = nothing].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L375-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_by_small_batch-Tuple{Any, Any}" href="#ModelVerification.propagate_by_small_batch-Tuple{Any, Any}"><code>ModelVerification.propagate_by_small_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_by_small_batch(f, x; sm_batch=500)</code></pre><p>Propagate the input <code>x</code> through <code>f</code> by small batches. This is useful when the  input <code>x</code> is too large to fit into GPU memory.</p><p><strong>Arguments</strong></p><ul><li><code>f</code> (function): Function to be applied to the input <code>x</code>.</li><li><code>x</code> (AbstractArray): Input to be propagated through <code>f</code>.</li><li><code>sm_batch</code> (Int): Optional argument for the size of the small batch, default    is 500.</li></ul><p><strong>Returns</strong></p><ul><li>Output of <code>f</code> applied to the input <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ImageStar, Flux.Conv, ModelVerification.ImageStarBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ImageStar, Flux.Conv, ModelVerification.ImageStarBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ImageStar, layer::Conv, 
                 bound::ImageStarBound, batch_info)</code></pre><p>Propagate the <code>ImageStarBound</code> bound through a convolution layer. I.e., it  applies the convolution operation to the <code>ImageStarBound</code> bound. The convolution  operation is applied to both the center and the generators of the  <code>ImageStarBound</code> bound. Using the <code>Flux.Conv</code>, a convolutional layer is made in  <code>Flux</code> with the given <code>layer</code> properties. While <code>cen_Conv</code> (convolutional layer  for the center image) uses the bias, the <code>gen_Conv</code> (convolutional layer for the  generators) does not. The resulting bound is also of type <code>ImageStarBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): The <code>ImageStar</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>Conv</code>): The convolution operation to be used for propagation.</li><li><code>bound</code> (<code>ImageStarBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The convolved bound of the output layer represented in <code>ImageStarBound</code> type.                     </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L125-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ImageStar, Flux.ConvTranspose, ModelVerification.ImageStarBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ImageStar, Flux.ConvTranspose, ModelVerification.ImageStarBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ImageStar, layer::ConvTranspose, 
                 bound::ImageStarBound, batch_info)</code></pre><p>Propagate the <code>ImageStarBound</code> bound through a convolutional transpose layer.  I.e., it applies the convolutional transpose operation to the <code>ImageStarBound</code>  bound. While a regular convolution reduces the spatial dimensions of an input, a  convolutional transpose expands the spatial dimensions of an input. The convolutional transpose operation is applied to both the center and  the generators of the <code>ImageStarBound</code> bound. Using the <code>Flux.ConvTranspose</code>, a  convolutional tranpose layer is made in <code>Flux</code> with the given <code>layer</code>  properties. While <code>cen_Conv</code> (convolutional transpose layer for the center  image) uses the bias, the <code>gen_Conv</code> (convolutional transpose layer for the  generators) does not. The resulting bound is also of type <code>ImageStarBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): The <code>ImageStar</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>ConvTranspose</code>): The convolutional transpose operation to be used    for propagation.</li><li><code>bound</code> (<code>ImageStarBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The convolved bound of the output layer represented in <code>ImageStarBound</code> type.                          </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L295-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ImageZono, Flux.ConvTranspose, ModelVerification.ImageZonoBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ImageZono, Flux.ConvTranspose, ModelVerification.ImageZonoBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ImageZono, layer::ConvTranspose, 
                 bound::ImageZonoBound, batch_info)</code></pre><p>Propagate the <code>ImageZonoBound</code> bound through a convolutional transpose layer.  I.e., it applies the convolutional transpose operation to the <code>ImageZonoBound</code>  bound. While a regular convolution reduces the spatial dimensions of an input, a  convolutional transpose expands the spatial dimensions of an input. The convolutional transpose operation is applied to both the center and  the generators of the <code>ImageZonoBound</code> bound. Using the <code>Flux.ConvTranspose</code>, a  convolutional tranpose layer is made in <code>Flux</code> with the given <code>layer</code>  properties. While <code>cen_Conv</code> (convolutional transpose layer for the center  image) uses the bias, the <code>gen_Conv</code> (convolutional transpose layer for the  generators) does not. The resulting bound is also of type <code>ImageZonoBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageZono</code>): The <code>ImageZono</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>ConvTranspose</code>): The convolutional transpose operation to be used    for propagation.</li><li><code>bound</code> (<code>ImageZonoBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The convolved bound of the output layer represented in <code>ImageZonoBound</code> type.              </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L242-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.Conv, ModelVerification.BetaCrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.Conv, ModelVerification.BetaCrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch(prop_method::BetaCrown, layer::Conv, 
                       bound::BetaCrownBound, batch_info)</code></pre><p>Propagates the bounds through the Conv layer for <code>BetaCrown</code> solver. It  operates an conv transformation on the given input bound and returns the output bound. It first preprocesses the lower- and upper-bounds of the bias of  the node using <code>_preprocess</code>. Then, it computes the interval map of the  resulting lower- and upper-bounds using <code>conv_bound_oneside</code> function. The  resulting bound is represented by <code>BetaCrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BetaCrown</code>): <code>BetaCrown</code> solver used for the verification    process.</li><li><code>layer</code> (<code>Conv</code>): Conv layer of the model.</li><li><code>bound</code> (<code>BetaCrownBound</code>): Bound of the input, represented by    <code>BetaCrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>New_bound</code> (<code>BetaCrownBound</code>): Bound of the output after affine    transformation, which is represented by <code>BetaCrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L626-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.ConvTranspose, ModelVerification.BetaCrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.ConvTranspose, ModelVerification.BetaCrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><p>propagate<em>layer</em>batch(prop<em>method::BetaCrown, layer::ConvTranspose,                             bound::BetaCrownBound, batch</em>info)</p><p>Propagates the bounds through the ConvTranspose layer for <code>BetaCrown</code> solver. It  operates an ConvTranspose transformation on the given input bound and returns the output bound. It first preprocesses the lower- and upper-bounds of the bias of  the node using <code>_preprocess</code>. Then, it computes the interval map of the  resulting lower- and upper-bounds using <code>convtrans_bound_oneside</code> function. The  resulting bound is represented by <code>BetaCrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BetaCrown</code>): <code>BetaCrown</code> solver used for the verification    process.</li><li><code>layer</code> (<code>ConvTranspose</code>): ConvTranspose layer of the model.</li><li><code>bound</code> (<code>BetaCrownBound</code>): Bound of the input, represented by    <code>BetaCrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>New_bound</code> (<code>BetaCrownBound</code>): Bound of the output after affine    transformation, which is represented by <code>BetaCrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L725-L747">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forward prop for CNN, Crown, box is not using symbolic bound</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L159-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch_box-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch_box-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch_box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch_box(prop_method::Crown, layer::Conv, 
                       bound::CrownBound, batch_info)</code></pre><p>Propagates the bounds through the convolution layer for <code>Crown</code> solver. It operates an convolutional transformation on the given input bound and returns the output bound. It first concretizes the bounds and forward pro asp using <code>batch_interval_map</code> function.  Then the bound is initalized again <code>CrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Crown</code>): <code>Crown</code> solver used for the verification process.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>bound</code> (<code>CrownBound</code>): Bound of the input, represented by <code>CrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_bound</code> (<code>CrownBound</code>): Bound of the output after affine transformation,    which is represented by <code>CrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L171-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch_symbolic-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch_symbolic-Tuple{Crown, Flux.Conv, ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch_symbolic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch_symbolic(prop_method::Crown, layer::Conv, 
                       bound::CrownBound, batch_info)</code></pre><p>Propagates the bounds through the convolution layer for <code>Crown</code> solver. It operates an convolutional transformation on the given input bound and returns the output bound. It adopt symbolic forward prop using <code>batch_interval_map</code> function.  Then the bound is initalized again <code>CrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Crown</code>): <code>Crown</code> solver used for the verification process.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>bound</code> (<code>CrownBound</code>): Bound of the input, represented by <code>CrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_bound</code> (<code>CrownBound</code>): Bound of the output after affine transformation,    which is represented by <code>CrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/convolution.jl#L210-L228">source</a></section></article><h2 id="Dense"><a class="docs-heading-anchor" href="#Dense">Dense</a><a id="Dense-1"></a><a class="docs-heading-anchor-permalink" href="#Dense" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification._preprocess" href="#ModelVerification._preprocess"><code>ModelVerification._preprocess</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">_preprocess(node, batch_info, bias = nothing)</code></pre><p>Preprocesses the bias of the given node for the <code>BetaCrown</code> solver. If the bias is not <code>nothing</code>, it multiplies the bias with the beta value of the node.</p><p><strong>Arguments</strong></p><ul><li><code>node</code>: Node of the model.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li><li><code>bias</code>: Bias of the node, default is <code>nothing</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>bias</code>: Preprocessed bias of the node.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L216-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.batch_interval_map-Union{Tuple{N}, Tuple{AbstractMatrix{N}, AbstractArray, AbstractArray}} where N" href="#ModelVerification.batch_interval_map-Union{Tuple{N}, Tuple{AbstractMatrix{N}, AbstractArray, AbstractArray}} where N"><code>ModelVerification.batch_interval_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">batch_interval_map(W::AbstractMatrix{N}, l::AbstractArray, 
                   u::AbstractArray) where N</code></pre><p>Clamps the input to the given bounds and computes the interval map of the  resulting bound using the given weight matrix.</p><p><strong>Arguments</strong></p><ul><li><code>W</code> (<code>AbstractMatrix{N}</code>): Weight matrix of the layer.</li><li><code>l</code> (<code>AbstractArray</code>): Lower bound of the input.</li><li><code>u</code> (<code>AbstractArray</code>): Upper bound of the input.</li></ul><p><strong>Returns</strong></p><p>Tuple of:</p><ul><li><code>l_new</code> (<code>AbstractArray</code>): Lower bound of the output.</li><li><code>u_new</code> (<code>AbstractArray</code>): Upper bound of the output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L142-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.dense_bound_oneside-Tuple{Any, Any, Any}" href="#ModelVerification.dense_bound_oneside-Tuple{Any, Any, Any}"><code>ModelVerification.dense_bound_oneside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dense_bound_oneside(weight, bias, batch_size)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L241-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Box, Flux.Dense, LazySets.LazySet, Any}" href="#ModelVerification.propagate_layer-Tuple{Box, Flux.Dense, LazySets.LazySet, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::Box, layer::Dense, reach::LazySet, batch_info)</code></pre><p>Propagate the bounds through the dense layer for Ai2 <code>Box</code> solver. It operates  an approximate affine transformation (affine transformation using hyperrectangle  overapproximation) on the given input bound and returns the output bound. </p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Box</code>): Ai2 <code>Box</code> solver used for the verification process.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>reach</code> (<code>LazySet</code>): Bound of the input.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>reach</code> (<code>hyperrectangle</code>): Bound of the output after approximate affine    transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L71-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ExactReach, Flux.Dense, ModelVerification.ExactReachBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ExactReach, Flux.Dense, ModelVerification.ExactReachBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ExactReach, layer::Dense, 
                 reach::ExactReachBound, batch_info)</code></pre><p>Propagate the bounds through the dense layer. It operates an affine  transformation on the given input bound and returns the output bound for  <code>ExactReach</code> solver.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ExactReach</code>): Exact reachability method used for the    verification process. This is one of the solvers used to verify the given    model.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>reach</code> (<code>ExactReachBound</code>): Bound of the input, represented by    <code>ExactReachBound</code> type, which is a vector of <code>LazySet</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>reach</code> (<code>ExactReachBound</code>): Bound of the output after affine transformation,    which is represented by <code>ExactReachBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L29-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ModelVerification.ForwardProp, Flux.Dense, LazySets.LazySet, Any}" href="#ModelVerification.propagate_layer-Tuple{ModelVerification.ForwardProp, Flux.Dense, LazySets.LazySet, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ForwardProp, layer::Dense, 
                 reach::LazySet, batch_info)</code></pre><p>Propagate the bounds through the dense layer. It operates an affine  transformation on the given input bound and returns the output bound.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ForwardProp</code>): Forward propagation method used for the    verification process. This is one of the solvers used to verify the given    model.                  </li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>reach</code> (<code>LazySet</code>): Bound of the input.</li><li><code>batch_info</code>: Dictionary containing information of each node in the    model.</li></ul><p><strong>Returns</strong></p><ul><li><code>reach</code> (<code>LazySet</code>): Bound of the output after affine transformation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.Dense, ModelVerification.BetaCrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.Dense, ModelVerification.BetaCrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch(prop_method::BetaCrown, layer::Dense, 
                       bound::BetaCrownBound, batch_info)</code></pre><p>Propagates the bounds through the dense layer for <code>BetaCrown</code> solver. It  operates an affine transformation on the given input bound and returns the output bound. It first preprocesses the lower- and upper-bounds of the bias of  the node using <code>_preprocess</code>. Then, it computes the interval map of the  resulting lower- and upper-bounds using <code>dense_bound_oneside</code> function. The  resulting bound is represented by <code>BetaCrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>BetaCrown</code>): <code>BetaCrown</code> solver used for the verification    process.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>bound</code> (<code>BetaCrownBound</code>): Bound of the input, represented by    <code>BetaCrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>New_bound</code> (<code>BetaCrownBound</code>): Bound of the output after affine    transformation, which is represented by <code>BetaCrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L267-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.Dense, ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.Dense, ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch(prop_method::Crown, layer::Dense, 
                       bound::CrownBound, batch_info)</code></pre><p>Propagates the bounds through the dense layer for <code>Crown</code> solver. It operates an affine transformation on the given input bound and returns the output bound. It first clamps the input bound and multiplies with the weight matrix using  <code>batch_interval_map</code> function. Then, it adds the bias to the output bound. The resulting bound is represented by <code>CrownBound</code> type.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Crown</code>): <code>Crown</code> solver used for the verification process.</li><li><code>layer</code> (<code>Dense</code>): Dense layer of the model.</li><li><code>bound</code> (<code>CrownBound</code>): Bound of the input, represented by <code>CrownBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>new_bound</code> (<code>CrownBound</code>): Bound of the output after affine transformation,    which is represented by <code>CrownBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/dense.jl#L169-L188">source</a></section></article><h2 id="Identity"><a class="docs-heading-anchor" href="#Identity">Identity</a><a id="Identity-1"></a><a class="docs-heading-anchor-permalink" href="#Identity" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ModelVerification.ForwardProp, typeof(identity), Any, Any}" href="#ModelVerification.propagate_layer-Tuple{ModelVerification.ForwardProp, typeof(identity), Any, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method, σ::typeof(identity), bound, batch_info)</code></pre><p>Propagate the bounds through the identity activation layer.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code>: Propagation method.</li><li><code>σ</code>: Identity activation function.</li><li><code>bound</code>: Bounds of the input.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li><code>bound</code>: Bounds of the output, which is equivalent to the bounds of the input.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/identity.jl#L1-L14">source</a></section></article><h2 id="Normalise"><a class="docs-heading-anchor" href="#Normalise">Normalise</a><a id="Normalise-1"></a><a class="docs-heading-anchor-permalink" href="#Normalise" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.bn_bound_oneside-NTuple{6, Any}" href="#ModelVerification.bn_bound_oneside-NTuple{6, Any}"><code>ModelVerification.bn_bound_oneside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bn_bound_oneside(last_A, weight, bias, stride, pad, dilation, groups, size_before_layer,size_after_layer, batch_size)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L323-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ImageStar, Flux.BatchNorm, ModelVerification.ImageStarBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ImageStar, Flux.BatchNorm, ModelVerification.ImageStarBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ImageStar, layer::BatchNorm, 
                 bound::ImageStarBound, batch_info)</code></pre><p>Propagate the <code>ImageStarBound</code> bound through a batch norm layer. I.e., it  applies the batch norm operation to the <code>ImageStarBound</code> bound. The batch norm  operation is decomposed into two operations: centering and scaling. The  centering operation is applied to the center of the <code>ImageStarBound</code> bound. The scaling operation is applied to the generators of the <code>ImageStarBound</code> bound. The resulting bound is also of type <code>ImageStarBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageStar</code>): The <code>ImageStar</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>BatchNorm</code>): The batch norm operation to be used for propagation.</li><li><code>bound</code> (<code>ImageStarBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The batch normed bound of the output layer represented in <code>ImageStarBound</code>    type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ImageZono, Flux.BatchNorm, ModelVerification.ImageZonoBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ImageZono, Flux.BatchNorm, ModelVerification.ImageZonoBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ImageZono, layer::BatchNorm, 
                 bound::ImageZonoBound, batch_info)</code></pre><p>Propagate the <code>ImageZonoBound</code> bound through a batch norm layer. I.e., it  applies the batch norm operation to the <code>ImageZonoBound</code> bound. The batch norm  operation is decomposed into two operations: centering and scaling. The  centering operation is applied to the center of the <code>ImageZonoBound</code> bound. The scaling operation is applied to the generators of the <code>ImageZonoBound</code> bound. The resulting bound is also of type <code>ImageZonoBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ImageZono</code>): The <code>ImageZono</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>BatchNorm</code>): The batch norm operation to be used for propagation.</li><li><code>bound</code> (<code>ImageZonoBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The batch normed bound of the output layer represented in <code>ImageZonoBound</code>    type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L34-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.BatchNorm, ModelVerification.BetaCrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{BetaCrown, Flux.BatchNorm, ModelVerification.BetaCrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_linear(prop_method::BetaCrown, layer::BatchNorm, 
                 bound::BetaCrownBound, batch_info)</code></pre><p>Propagate the <code>BetaCrownBound</code> bound through a batch norm layer. I.e., it  applies the &quot;inverse&quot; batch norm operation to the <code>BetaCrownBound</code> bound.  The resulting bound is also of type <code>BetaCrownBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Crown</code>): The <code>Crown</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>BetaCrown</code>): The batch norm operation to be used for propagation.</li><li><code>bound</code> (<code>BetaCrownBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The batch normed bound of the output layer represented in <code>BetaCrownBound</code>    type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L254-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.BatchNorm, ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{Crown, Flux.BatchNorm, ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::Crown, layer::BatchNorm, 
                 bound::CrownBound, batch_info)</code></pre><p>Propagate the <code>CrownBound</code> bound through a batch norm layer. I.e., it  applies the batch norm operation to the <code>CrownBound</code> bound.  The resulting bound is also of type <code>CrownBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Crown</code>): The <code>Crown</code> propagation method used for the    verification problem.</li><li><code>layer</code> (<code>BatchNorm</code>): The batch norm operation to be used for propagation.</li><li><code>bound</code> (<code>CrownBound</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The batch normed bound of the output layer represented in <code>CrownBound</code>    type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L131-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{Flux.BatchNorm, AbstractArray, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{Flux.BatchNorm, AbstractArray, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch(layer::BatchNorm, batch_reach::AbstractArray, 
                       batch_info)</code></pre><p>Propagate the <code>batch_reach</code> through a batch norm layer. I.e., it applies the  batch norm operation to the <code>batch_reach</code>. The batch norm operation is  decomposed into two operations: centering and scaling. This function supports  input batch with channel dimension.</p><p><strong>Arguments</strong></p><ul><li><code>layer</code> (<code>BatchNorm</code>): The batch norm operation to be used for propagation.</li><li><code>batch_reach</code> (<code>AbstractArray</code>): The batch of input bounds.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The batch normed bound of the output layer.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/normalise.jl#L87-L103">source</a></section></article><h2 id="ReLU"><a class="docs-heading-anchor" href="#ReLU">ReLU</a><a id="ReLU-1"></a><a class="docs-heading-anchor-permalink" href="#ReLU" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.ImageStar_to_Star-Tuple{ModelVerification.ImageStarBound}" href="#ModelVerification.ImageStar_to_Star-Tuple{ModelVerification.ImageStarBound}"><code>ModelVerification.ImageStar_to_Star</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ImageStar_to_Star(bound::ImageStarBound)</code></pre><p>Convert the <code>ImageStarBound</code> bound to <code>Star</code> bound.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>ImageStarBound</code>): The bound of the input node, represented using    <code>ImageStarBound</code> type.</li></ul><p><strong>Returns</strong></p><ul><li>The bound represented using <code>Star</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L430-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.Star_to_ImageStar-Tuple{LazySets.Star, Any}" href="#ModelVerification.Star_to_ImageStar-Tuple{LazySets.Star, Any}"><code>ModelVerification.Star_to_ImageStar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Star_to_ImageStar(bound::Star, sz)</code></pre><p>Converts the <code>Star</code> bound to <code>ImageStarBound</code> bound.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code> (<code>Star</code>): The bound of the input node, represented using <code>Star</code> type.</li><li><code>sz</code>: The size of the input image, i.e., the target size.</li></ul><p><strong>Returns</strong></p><ul><li>The bound represented using <code>ImageStarBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L449-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.bound_oneside-Tuple{Any, Any, Any}" href="#ModelVerification.bound_oneside-Tuple{Any, Any, Any}"><code>ModelVerification.bound_oneside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bound_oneside(last_A, slope_pos, slope_neg)</code></pre><p>Bound the ReLU activation function from one side, such as upper or lower.</p><p><strong>Arguments</strong></p><ul><li><code>last_A</code>: The last layer&#39;s activation.</li><li><code>slope_pos</code>: The slope of the ReLU activation function from the positive side.</li><li><code>slope_neg</code>: The slope of the ReLU activation function from the negative side.</li></ul><p><strong>Returns</strong></p><ul><li>The bound of the ReLU activation function from one side.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L682-L694">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.fast_overapproximate-Union{Tuple{N}, Tuple{LazySets.Rectification{N, &lt;:LazySets.AbstractZonotope}, Type{&lt;:LazySets.Zonotope}}} where N" href="#ModelVerification.fast_overapproximate-Union{Tuple{N}, Tuple{LazySets.Rectification{N, &lt;:LazySets.AbstractZonotope}, Type{&lt;:LazySets.Zonotope}}} where N"><code>ModelVerification.fast_overapproximate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fast_overapproximate(r::Rectification{N,&lt;:AbstractZonotope}, 
                     ::Type{&lt;:Zonotope}) where {N}</code></pre><p>Computes the overapproximation of the rectified set <code>r</code> using a Zonotope.</p><p><strong>Arguments</strong></p><ul><li><code>r</code> (<code>Rectification</code>): The rectified set.</li><li><code>::Type{&lt;:Zonotope}</code>: The type of the overapproximation, default is    <code>Zonotope</code>.</li></ul><p><strong>Returns</strong></p><ul><li>The overapproximation of the rectified set <code>r</code> using a Zonotope.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L166-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.multiply_by_A_signs-Tuple{Any, Any, Any}" href="#ModelVerification.multiply_by_A_signs-Tuple{Any, Any, Any}"><code>ModelVerification.multiply_by_A_signs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiply_by_A_signs(last_A, slope_pos, slope_neg)</code></pre><p>Multiply the last layer&#39;s activation by the sign of the slope of the ReLU  activation function. This is for <code>BetaLayer</code> propagation method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L638-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.partition_relu-Tuple{Any}" href="#ModelVerification.partition_relu-Tuple{Any}"><code>ModelVerification.partition_relu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_relu(bound)</code></pre><p>Partition the <code>bound</code> into multiple <code>VPolytope</code> objects, each of which is the  intersection of the <code>bound</code> and an orthant. The resulting <code>VPolytope</code> objects  are stored in an array. This is for ReLU propagations in <code>ExactReach</code> solver. Thus, the resulting <code>VPolytope</code> objects are the outputs of rectifying the input  bound. The dimension of the <code>bound</code> must be less than 30, since otherwise the  number of output sets will be too large.</p><p><strong>Arguments</strong></p><ul><li><code>bound</code>: The bound of the input node.</li></ul><p><strong>Returns</strong></p><ul><li>An array of partitioned bounds represented using <code>VPolytope</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L28-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), LazySets.Star, Any}" href="#ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), LazySets.Star, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method, layer::typeof(relu), bound::Star, batch_info)</code></pre><p>Propagate the <code>Star</code> bound through a ReLU layer. I.e., it applies the ReLU  operation to the <code>Star</code> bound. The resulting bound is also of type <code>Star</code>. This  is for <code>Star</code> propagation methods.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code>: The propagation method used for the verification problem.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>bound</code> (<code>Star</code>): The bound of the input node, represented using <code>Star</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>the relued bound of the output represented in <code>Star</code> type.</li></ul><p><strong>Reference</strong></p><p>[1] HD. Tran, S. Bak, W. Xiang, and T.T. Johnson, &quot;Verification of Deep Convolutional  Neural Networks Using ImageStars,&quot; in <em>Computer Aided Verification (CAV)</em>, 2020.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L343-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), ModelVerification.ImageStarBound, Any}" href="#ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), ModelVerification.ImageStarBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method, layer::typeof(relu), 
              bound::ImageStarBound, batch_info)</code></pre><p>Propagate the <code>ImageStarBound</code> bound through a ReLU layer. I.e., it applies  the ReLU operation to the <code>ImageStarBound</code> bound. The resulting bound is also  of type <code>ImageStarBound</code>. This is for <code>ImageStar</code> propagation method. It  converts the input bound to <code>Star</code> type, calls <code>propagate_layer</code> that propagates  the <code>Star</code> bound through a ReLU layer, and converts the resulting bound back to  <code>ImageStarBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code>: The propagation method used for the verification problem.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>bound</code> (<code>ImageStarBound</code>): The bound of the input node, represented using    <code>ImageStarBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>The relued bound of the output represented in <code>ImageStarBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L470-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), ModelVerification.ImageZonoBound, Any}" href="#ModelVerification.propagate_layer-Tuple{Any, typeof(NNlib.relu), ModelVerification.ImageZonoBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method, layer::typeof(relu), 
              bound::ImageZonoBound, batch_info)</code></pre><p>Propagate the <code>ImageZonoBound</code> bound through a ReLU layer. I.e., it applies  the ReLU operation to the <code>ImageZonoBound</code> bound. The resulting bound is also  of type <code>ImageZonoBound</code>. This is for <code>ImageZono</code> propagation method. It  flattens the input bound into a <code>Zonotope</code> and calls <code>fast_overapproximate</code> that  computes the overapproximation of the rectified set using a Zonotope. It then  converts the resulting <code>Zonotope</code> back to <code>ImageZonoBound</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code>: The propagation method used for the verification problem.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>bound</code> (<code>ImageZonoBound</code>): The bound of the input node, represented using    <code>ImageZonoBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>the relued bound of the output represented in <code>ImageZonoBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L270-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Box, typeof(NNlib.relu), LazySets.AbstractPolytope, Any}" href="#ModelVerification.propagate_layer-Tuple{Box, typeof(NNlib.relu), LazySets.AbstractPolytope, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::Box, layer::typeof(relu), 
              reach::AbstractPolytope, batch_info)</code></pre><p>Propagate the <code>AbstractPolytope</code> bound through a ReLU layer. I.e., it applies  the ReLU operation to the <code>AbstractPolytope</code> bound. The resulting bound is also  of type <code>AbstractPolytope</code>. This is for Ai2&#39;s <code>Box</code> propagation method. It calls  <code>rectify</code> that rectifies the input bound.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Box</code>): The propagation method used for the verification    problem.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>reach</code> (<code>AbstractPolytope</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>the relued bound of the output represented in <code>AbstractPolytope</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L95-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{ExactReach, typeof(NNlib.relu), ModelVerification.ExactReachBound, Any}" href="#ModelVerification.propagate_layer-Tuple{ExactReach, typeof(NNlib.relu), ModelVerification.ExactReachBound, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::ExactReach, layer::typeof(relu), 
              reach::ExactReachBound, batch_info)</code></pre><p>Propagate the <code>ExactReachBound</code> bound through a ReLU layer. I.e., it applies  the ReLU operation to the <code>ExactReachBound</code> bound. The resulting bound is also  of type <code>ExactReachBound</code>. This is for <code>ExactReach</code> propagation method. It calls <code>partition_relu</code> that partitions the resulting rectified bound into  multiple <code>VPolytope</code> objects, each of which is the intersection of the resulting  bound and an orthant. The resulting <code>VPolytope</code> objects are vertically  concatenated and stored in an <code>ExactReachBound</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>ExactReach</code>): The propagation method used for the verification    problem.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>reach</code> (<code>ExactReachBound</code>): The bound of the input node, represented using    <code>ExactReachBound</code> type.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>the relued bound of the output represented in <code>ExactReachBound</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L65-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer-Tuple{Union{ImageZono, Ai2z}, typeof(NNlib.relu), LazySets.AbstractPolytope, Any}" href="#ModelVerification.propagate_layer-Tuple{Union{ImageZono, Ai2z}, typeof(NNlib.relu), LazySets.AbstractPolytope, Any}"><code>ModelVerification.propagate_layer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer(prop_method::Union{Ai2z, ImageZono}, layer::typeof(relu), 
              reach::AbstractPolytope, batch_info)</code></pre><p>Propagate the <code>AbstractPolytope</code> bound through a ReLU layer. I.e., it applies  the ReLU operation to the <code>AbstractPolytope</code> bound. The resulting bound is also of type <code>AbstractPolytope</code>. This is for either <code>Ai2z</code> or <code>ImageZono</code> propagation  methods, which both use Zonotope-like representation for the safety  specifications. After rectifying the input bound, it overapproximates the  resulting bound using a Zonotope.</p><p><strong>Arguments</strong></p><ul><li><code>prop_method</code> (<code>Union{Ai2z, ImageZono}</code>): The propagation method used for the    verification problem. It can be either <code>Ai2z</code> or <code>ImageZono</code>, which both use    Zonotope-like representation for the safety specifications.</li><li><code>layer</code> (<code>typeof(relu)</code>): The ReLU operation to be used for propagation.</li><li><code>reach</code> (<code>AbstractPolytope</code>): The bound of the input node.</li><li><code>batch_info</code>: Dictionary containing information of each node in the model.</li></ul><p><strong>Returns</strong></p><ul><li>the relued bound of the output represented in <code>Zonotope</code> type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.propagate_layer_batch-Tuple{Crown, typeof(NNlib.relu), ModelVerification.CrownBound, Any}" href="#ModelVerification.propagate_layer_batch-Tuple{Crown, typeof(NNlib.relu), ModelVerification.CrownBound, Any}"><code>ModelVerification.propagate_layer_batch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">propagate_layer_batch(prop_method::Crown, layer::typeof(relu), 
                    bound::CrownBound, batch_info)</code></pre><p>Propagate the <code>CrownBound</code> bound through a ReLU layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L501-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelVerification.relu_upper_bound-Tuple{Any, Any}" href="#ModelVerification.relu_upper_bound-Tuple{Any, Any}"><code>ModelVerification.relu_upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relu_upper_bound(lower, upper)</code></pre><p>Compute the upper bound slope and intercept according to CROWN relaxation. </p><p><strong>Arguments</strong></p><ul><li><code>lower</code>: The lower bound of the input node, pre-ReLU operation.</li><li><code>upper</code>: The upper bound of the input node, pre-ReLU operation.</li></ul><p><strong>Returns</strong></p><ul><li>The upper bound slope and intercept according to CROWN relaxation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/intelligent-control-lab/ModelVerification.jl/blob/c95102aae6ebba2bbb8c55c0f5e1051feb7f47c2/src/propagate/operators/relu.jl#L616-L627">source</a></section></article><h2 id="Stateless"><a class="docs-heading-anchor" href="#Stateless">Stateless</a><a id="Stateless-1"></a><a class="docs-heading-anchor-permalink" href="#Stateless" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="branching.html">« Branching</a><a class="docs-footer-nextpage" href="solvers.html">Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 11 July 2024 20:46">Thursday 11 July 2024</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
